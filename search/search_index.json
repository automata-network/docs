{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Automata Network","text":"<p>Automata Network is the privacy middleware layer building for a fair Web3. Its core suite of products include 1RPC, 2FA Guru, NFTFair, AnyDAO and XATA to address perennial issues of exploitation on the blockchain without compromising on security.</p> <p>Some of our key features: - Do-not-track privacy - Native integration - Universal compatibility</p> <p>Our Medium is a great introduction to our vision and work. </p> <p>Overview</p> <p>Given the default transparency of blockchain, users struggle with moving large amount of their fortunes into what is invariably an exposed glass box. The developer experience is a central part of Automata's design and helps to explain our middleware approach. For blockchain projects to advocate for and adopt privacy at the protocol level, it's important to us to reduce integration friction and make the experience a positive one for builders, and further down the line, end-users. </p> <p>Some of our middleware solutions include Conveyor, a MEV Minimization solution, and Witness, for off-chain privacy governance. </p> <p>The best way to understand how we're doing this is to dive into our technical framework. Here's an ELI5 version.</p> <p>We're passionate about:</p> <ul> <li>Minimizing Maximal Extractable Value</li> <li>Fair NFT launches - no sniping! </li> <li>Borderless, privacy governance</li> <li>Neutralizing social engineering attacks</li> <li>Eradicating metadata exposure </li> </ul>"},{"location":"#for-developers","title":"For Developers","text":"<p>If you're interested in developing with or on Automata Network, view our developer guides for: - ContextFree, our Canary Network  - Conveyor, off-chain blockchain governance </p>"},{"location":"#for-users","title":"For Users","text":"<p>Browse through any of our user guides below to get started:</p> <ul> <li>XATA</li> <li>NFTFair</li> <li>AnyDAO</li> <li>2FA Guru</li> <li>1RPC</li> </ul>"},{"location":"#helpful-links","title":"Helpful links","text":"<ul> <li>Website</li> <li>Dashboard</li> <li>Faucet</li> </ul>"},{"location":"#questions","title":"Questions?","text":"<p>We're social creatures and active on a number of platforms. Find us on: </p> <ul> <li>Twitter</li> <li>Discord</li> <li>Telegram</li> </ul>"},{"location":"1rpc/design/","title":"Design","text":""},{"location":"1rpc/design/#design","title":"Design","text":"<p>1RPC employs a number of methods for users' data and metadata to remain private before requests are relayed to RPC providers. Its lightweight design is able to scale to support high traffic volume. </p>"},{"location":"1rpc/design/#overview","title":"Overview","text":"<p>There are a few terms to get yourself familarized with to understand the full extent of what 1RPC does and what it has to offer. </p> <p>When users perform any kind of action, such as viewing their balance, creating a transaction or bidding for an NFT, requests are submitted to the blockchain through an RPC. Typically, the RPC endpoint would be able to view, and sometimes store, such requests. These requests might contain both user data and metadata. </p> <ul> <li> <p>Data: Information related to any interaction on-chain is considered data</p> <ul> <li>Read requests such as wallet addresses, usually out of scope in terms of need-to-know </li> <li>Write requests which will be made public on-chain, if executed successfully</li> </ul> </li> <li> <p>Metadata: While not data itself, metadata provides or suggests information about data</p> <ul> <li>IP address (Geolocation)</li> <li>User agent (Browser version, OS platform)</li> <li>Request timestamp (Timezone)</li> </ul> </li> </ul>"},{"location":"1rpc/design/#zero-tracking-by-1rpc","title":"Zero tracking by 1RPC","text":""},{"location":"1rpc/design/#metadata-masking","title":"Metadata Masking","text":"<p>1RPC replaces metadata attached to a user\u2019s request with its own. What happens as a result is that the original metadata attached to a particular request, and any personal information that could identify the user, is removed from the view of RPC providers. </p>"},{"location":"1rpc/design/#random-dispatching","title":"Random Dispatching","text":"<p>1RPC dispatches requests randomly to RPC providers, breaking the linkability between wallets when a user sends multiple requests from different addresses consecutively. Shuffling requests as such makes it impossible to log the association between accounts with the same private key.</p>"},{"location":"1rpc/design/#request-caching","title":"Request Caching","text":"<p>Certain read-only queries are cached to reduce response time and reduce the information load passed to RPC providers. The current LRU (least recently used) policy will be upgraded as we learn more about usage and capacity requirements.</p>"},{"location":"1rpc/design/#burn-after-relaying","title":"Burn after relaying","text":"<p>1RPC neither stores nor collects metadata/data that passes through the relay, which are discarded once the request is completed. Because the RPC endpoint runs in a secure enclave, it is not possible for 1RPC to view, access, or tamper with the metadata within.</p>"},{"location":"1rpc/design/#multicall-disassociation","title":"Multicall Disassociation","text":"<p>A single RPC call that contains multiple batched queries can reveal the relationship between an umbrella of different accounts under the same wallet. When possible, 1RPC disassembles multicall transactions into its individual requests to prevent exposure. </p>"},{"location":"1rpc/faq/","title":"Frequently Asked Questions","text":""},{"location":"1rpc/faq/#how-does-1rpc-protect-my-data","title":"How does 1RPC protect my data?","text":"<p>Read up on what makes 1RPC different here, or check out the rest of it under our technical architecture. </p>"},{"location":"1rpc/faq/#what-makes-1rpc-different-from-the-other-rpc-providers","title":"What makes 1RPC different from the other RPC providers?","text":"<p>Automata\u2019s core mission is protecting fairness and privacy, which has inspired us to think about the design and implementation of 1RPC not only as a RPC relay, but also as a user-facing service that provides ease of use and convenience. Learning from real-world use has allowed us to improve the experience and discover new uses for 1RPC. We look forward to working closely together with more RPC providers to bring about greater visibility and control over user data and metadata within Web3. </p>"},{"location":"1rpc/faq/#will-1rpc-always-be-free","title":"Will 1RPC always be free?","text":"<p>Of course. Users who require more precise and comprehensive privacy controls can reserve a spot on the 1RPC+ waitlist once it opens up again. </p>"},{"location":"1rpc/faq/#which-wallets-can-i-use-1rpc-with","title":"Which wallets can I use 1RPC with?","text":"<p>EVM-compatible chains can already be used natively with MetaMask one-click deployment button. Alternatively, copy and paste the network\u2019s information to any wallet that supports customized RPC endpoints. OneKey and MathWallet offer native support for 1RPC, and we\u2019re also constantly working on the list of wallet partners for 1RPC, so be sure to check back often.</p> <p>Here's a 30 seconds tutorial on how to get started with 1RPC. </p>"},{"location":"1rpc/faq/#why-use-1rpc-if-my-privacy-is-already-compromised","title":"Why use 1RPC if my privacy is already compromised?","text":"<p>Any step you take to put an end to interactions that reveal personal information about you is great for your privacy. Because 1RPC practices metadata masking, that is, replacing metadata attached to a user\u2019s request with its own, the original metadata \u2014 and any identifying information \u2014 is shielded from third-party providers.</p> <p>While the best time to switch to 1RPC was after your initial wallet setup, the second best time is now.</p>"},{"location":"1rpc/guide/","title":"User Guide","text":""},{"location":"1rpc/guide/#user","title":"User","text":"<p>Visit 1RPC. Click on the \"Add 1RPC to Wallet\" button.  </p> <p></p> <p>Search for the network by token, name or Chain ID.</p> <p></p> <p>Click on the MetaMask icon to switch to 1RPC instantly. </p> <p></p> <p>Alternatively, click on View Details. Copy the network information to your wallet settings. </p> <p></p> <p>For Substrate blockchains, switch to 1RPC on Polkadot.js</p> <p></p>"},{"location":"1rpc/guide/#developer","title":"Developer","text":"<p>Replace the existing URL with 1RPC's endpoint URL to interact with the blockchain.</p> CurlGoWeb3.jsPythonWebsocket <pre><code>curl --request POST \\\n--url https://1rpc.io/eth \\\n--header 'Accept: application/json' \\\n--header 'Content-Type: application/json' \\\n--data '\n{\n    \"id\": 1,\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"eth_blockNumber\"\n}\n'\n</code></pre> <pre><code>package main\n\nimport (\n\"context\"\n\"fmt\"\n\"github.com/ethereum/go-ethereum/ethclient\"\n)\n\nfunc main() {\nconst url = \"https://1rpc.io/eth\"  // url string\n\nrpcClient,err := ethclient.Dial(url)\n\nif err != nil {\npanic(err)\n}\n\nblockNumber, err := rpcClient.BlockNumber(context.Background())\n\nif err != nil {\npanic(err)\n}\n\nfmt.Println(blockNumber)\n}\n</code></pre> <pre><code>const Web3 = require('web3');\n\nconst url = 'https://1rpc.io/eth'  // url string\n\nconst web3 = new Web3(new Web3.providers.HttpProvider(url));\n\nweb3.eth.getBlockNumber((error, blockNumber) =&gt; {\nif(!error) {\nconsole.log(blockNumber);\n} else {\nconsole.log(error);\n}\n});\n</code></pre> <pre><code>from web3 import Web3\n\ndef test_block_number(self):\n    url = 'https://1rpc.io/eth'  # url string\n\n    web3 = Web3(HTTPProvider(url))\n    print(web3.eth.block_number)\n</code></pre> <pre><code>$ wscat -c wss://1rpc.io/dot\n\n&gt; {\"jsonrpc\":  \"2.0\", \"id\": 0, \"method\":  \"system_chainType\"}\n</code></pre>"},{"location":"1rpc/introduction/","title":"Introduction","text":""},{"location":"1rpc/introduction/#overview","title":"Overview","text":"<p>1RPC is a free RPC relay to eradicate metadata exposure and leakage with a one-click experience for users within Web3. As a proxy layer that shields user data before it reaches existing RPC endpoints, many of which continue to be centralized today, it is important to us that 1RPC neither collects nor stores user metadata in any part of the relay journey.</p> <p>To support the evolving needs of our budding community, we\u2019ve rolled out 1RPC+ to give users more granular, dynamic control of how they interact with the blockchain. Read more about 1RPC+ here - and how users create their own bespoke RPC endpoint with transaction sanitizers that can be added, edited or removed instantly, at any time. </p>"},{"location":"1rpc/introduction/#features","title":"Features","text":""},{"location":"1rpc/introduction/#public-good","title":"Public good","text":"<p>The task for privacy protection as a RPC relay has allowed us rare insight into what it takes to strike the balance between idealism and ease of use. More than ever, we\u2019re committed to making sure 1RPC remains a free service for users within Web3. </p>"},{"location":"1rpc/introduction/#one-click","title":"One-click","text":"<p>An intuitive user experience helps users to get the most out of 1RPC\u2019s privacy features. Clicking on the MetaMask icon for EVM-compatible chains will allow users to switch instantly to 1RPC. </p>"},{"location":"1rpc/introduction/#zero-tracking","title":"Zero tracking","text":"<p>Even ostensibly private transactions are liable to some form of tracing, but not on 1RPC. Skip ahead to 1RPC\u2019s design to read all about how we make it happen using a number of technical methods. </p>"},{"location":"1rpc/introduction/#multi-chain","title":"Multi-chain","text":"<p>1RPC currently supports 19 chains, with more being added to the list. Users can easily connect to the relay service either through the network RPC URL or Substrate WebSocket endpoint. </p>"},{"location":"1rpc/introduction/#supported-networks","title":"Supported networks","text":"Network Name 1RPC URL Chain ID Currency Symbol Block Explorer URL ETH Mainnet https://1rpc.io/eth 1 ETH https://etherscan.io BNB Chain Mainnet https://1rpc.io/bnb 56 BNB https://bscscan.com Polygon Mainnet https://1rpc.io/matic 137 MATIC https://polygonscan.com Avalanche Contract Chain https://1rpc.io/avax/c 43114 AVAX https://snowtrace.io Avalanche Platform Chain https://1rpc.io/avax/p Avalanche Exchange Chain https://1rpc.io/avax/x Arbitrum One https://1rpc.io/arb 42161 ETH https://arbiscan.io Moonbeam https://1rpc.io/glmr 1284 GLMR https://moonscan.io wss://1rpc.io/glmr Astar https://1rpc.io/astr 592 ASTR https://blockscout.com/astar wss://1rpc.io/astr Polkadot wss://1rpc.io/dot Kusama wss://1rpc.io/ksm Acala wss://1rpc.io/aca Optimism https://1rpc.io/op 10 ETH https://optimistic.etherscan.io zkSync Era Mainnet https://1rpc.io/zksync2-era 324 ETH https://explorer.zksync.io Fantom Opera https://1rpc.io/ftm 250 FTM https://ftmscan.com Celo Mainnet https://1rpc.io/celo 42220 CELO https://explorer.celo.org Klaytn Mainnet https://1rpc.io/klay 8217 KLAY https://www.klaytnfinder.io Starknet https://1rpc.io/starknet https://starkscan.co AltLayer https://1rpc.io/alt 9990 ALT https://devnet-explorer.altlayer.io Near Mainnet https://1rpc.io/near https://explorer.near.org Aurora Mainnet https://1rpc.io/aurora 1313161554 ETH https://explorer.mainnet.aurora.dev Base Goerli https://1rpc.io/base-goerli 84531 ETH https://goerli.basescan.org"},{"location":"1rpc/introduction/#limitations","title":"Limitations","text":"<ul> <li>Rate limit for 1RPC: 40 requests per second, 20,000 requests per day</li> </ul> <p>Daily usage quota will reset in the following day (00:00 UTC). An error code -32001 will be displayed once the rate limit is reached. </p> <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32001, \"message\": \"Exceeded the quota usage\"}, \"id\": 1}\n</code></pre> <ul> <li>Request content size: 2 Megabytes (MB)</li> </ul> <p>An error code -32600 will be displayed once the request limit is reached. </p> <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32600, \"message\": \"JSON RPC Request is too large\"}, \"id\": 1}\n</code></pre> <ul> <li>Response content size: 2 Megabytes (MB)</li> </ul> <p>An error code -32000 will be displayed once the response limit is reached. Trying to call the eth_getLogs method might increase the content size, which can be brought down by refining the request, such as reducing the block range. </p> <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32000, \"message\": \"response size should not greater than 2097152 bytes\"}, \"id\": 1}\n</code></pre>"},{"location":"1rpc/1rpcplus/guide/","title":"User Guide","text":"<p>Click on the \"Sign in\" button on the top right of the page. 1RPC+ is currently in private alpha and accessible via waitlist only, so check that you\u2019re using the correct wallet address.</p> <p></p> <p>A pop-up will appear. Click on the wallet icons to connect your wallet. </p> <p></p> <p>Sign the message to begin using 1RPC+. </p> <p></p> <p>This is the dashboard for 1RPC+ members. The API key on the dashboard is unique to you and is used to generate 1RPC+ URLs across all supported networks. </p> <p></p> <p>To create a new API key, click on \"Rotate Key\". Note that the existing key will be deactivated permanently, as will all other 1RPC+ endpoints associated with it. For instance, the URL for Ethereum on that API key will no longer be in use. Click on the wallet icon to connect your wallet using your new API key. </p> <p></p> <p>The status gives an indication of the daily limit for the number of relays supported on 1RPC+ for each user. The counter resets on UTC+0 00:00 each day. </p> <p></p> <p>Hover over the wallet icons and click on your preferred wallet to switch to 1RPC+ instantly. Here we\u2019re using MetaMask as an example to illustrate what that would look like. The experience for different wallets should be similar. </p> <p></p> <p>Let\u2019s select the MetaMask icon under Ethereum. Sign the following messages to switch to 1RPC+ on the network. </p> <p></p>"},{"location":"1rpc/1rpcplus/guide/#transaction-sanitizers","title":"Transaction Sanitizers","text":"<p>Click on \"Customize\" in the top right corner of 1RPC+ dashboard. </p> <p></p> <p>This is where you will be able to add and edit transaction sanitizers. Click on the information icon to learn more about each rule. </p> <ul> <li>To enable a sanitizer, simply click on the toggle button to switch it on. </li> <li>To disable it, click on the same button to switch it off. </li> <li>1RPC+ helps to remember the same settings if you rotate your API key. </li> <li>Click on \u201cReset settings\u201d to clear any previous selections. </li> <li>The shield icon is accompanied by a numerical value that represents the total count of transactions identified as fraudulent or malicious, and which are subsequently blocked by the transaction sanitizer.</li> </ul> <p></p>"},{"location":"1rpc/1rpcplus/guide/#address-whitelistblacklist","title":"Address whitelist/blacklist","text":"<ul> <li>Users can either create a blacklist or whitelist</li> <li>To create a list, input the address into the column and click Enter. A valid address will turn green and become a correct entry.</li> <li>To delete the list or edit the list title, click on the 3 vertical dots beside it. </li> <li>To add a new list, click on \u2018Create a new list\u2019 at the top </li> </ul>"},{"location":"1rpc/1rpcplus/guide/#uniswap-recipient-validation","title":"Uniswap recipient validation","text":"<ul> <li>1RPC+ matches the recipient\u2019s address against its sender to confirm the validity of the address.</li> <li>This ensures that you\u2019re swapping tokens to the correct recipient address. </li> </ul>"},{"location":"1rpc/1rpcplus/guide/#goplus-address-scanning","title":"GoPlus address scanning","text":"<ul> <li>1RPC+ decodes the addresses that the user interacts with and verifies whether any of them is malicious by using GoPlus address API.</li> </ul>"},{"location":"1rpc/1rpcplus/guide/#avengerdao-address-scanning","title":"AvengerDAO address scanning","text":"<ul> <li>1RPC+ decodes the addresses that the user interacts with and ensures that the trust score based on risk levels provided by AvengerDAO Meter satisfies the threshold specified by the user.</li> <li>The trust score is an indicator of the level of vigilance and caution exercised, with higher scores corresponding to more stringent checks. </li> </ul>"},{"location":"1rpc/1rpcplus/guide/#explorer-contract-verification","title":"Explorer contract verification","text":"<ul> <li>1RPC+ ensures that the contract that you are interacting with is verified on the chain\u2019s official blockchain explorer. e.g., etherscan for Ethereum.</li> <li>Verification means that the source code of the contract is made accessible for public viewing on the blockchain explorer. </li> </ul> <p>Should a transaction fail, users can click on the error message to find out more about the transaction sanitizer that was applied. Alternatively, read more about rules and limitations on 1RPC+ here. </p> <p></p>"},{"location":"1rpc/1rpcplus/introduction/","title":"Introduction","text":""},{"location":"1rpc/1rpcplus/introduction/#overview","title":"Overview","text":"<p>1RPC+ is a subscription plan that offers users more granular, dynamic control of their interaction with blockchain. </p> <p>The waitlist for 1RPC+ is now at capacity, and we will begin to invite users over the next few weeks. </p>"},{"location":"1rpc/1rpcplus/introduction/#features","title":"Features","text":""},{"location":"1rpc/1rpcplus/introduction/#transaction-sanitizers","title":"Transaction sanitizers","text":"<p>Transaction sanitizers deter both known and emerging phishing threats that precede a potential loss of funds. Anti-phishing rules help users to avoid interactions with bad actors. Address scanning warns against a network of known, malicious addresses and smart contracts. Explorer contract verification and recipient validation on exchanges such as Uniswap ensures that users are interacting with genuine, official sources. </p>"},{"location":"1rpc/1rpcplus/introduction/#bespoke-rpc","title":"Bespoke RPC","text":"<p>Users of 1RPC+ own and customize a unique RPC endpoint to structure their journey in Web3, instead of having to go along with a blanket protection policy. 1RPC+ provides clarity for users on how they interact with a dApp or smart contract. This offers a more intuitive experience, but also the freedom of choice to strike a balance between user convenience and privacy protection. </p>"},{"location":"1rpc/1rpcplus/introduction/#fail-safe-protection","title":"Fail-safe protection","text":"<p>1RPC+ users are buffered from potential phishing attempts even if its wider technical environment becomes vulnerable to such attacks. For the user on a wallet that does not offer native anti-phishing protection, 1RPC+ will still be able to detect and prevent malicious transactions from taking place in real-time, ao long as the relevant transaction sanitizer was set up in the first place. </p>"},{"location":"1rpc/1rpcplus/spec/","title":"Specification","text":""},{"location":"1rpc/1rpcplus/spec/#usage-quota","title":"Usage quota","text":"<ul> <li>Rule ID: 001</li> <li>Rule Details: There is a default daily usage quota for each 1RPC+ user, and if it reaches the limitation, 1RPC+ will stop the upcoming requests until the following day (00:00 UTC).</li> <li>Default quota: 40,000</li> <li>Error code: -32001</li> <li>Error message: Exceeded the quota usage</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32001, \"message\": \"Exceeded the quota usage\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"1rpc/1rpcplus/spec/#address-whitelistblacklist","title":"Address whitelist/blacklist","text":"<ul> <li>Rule ID: 002</li> <li>Rule Details: 1RPC+ users are able to create, edit and maintain one or many lists of addresses they trust or don't trust. 1RPC+ will encrypt and save these lists as a part of the customized configuration. For each eth_sendRawTransaction request, 1RPC+ will decode the addresses that the users interact with, then validate these addresses by using users\u2019 config.</li> <li>Support methods:<ul> <li>approve</li> <li>setApprovalForAll</li> <li>transferFrom</li> <li>safeTransferFrom</li> <li>transfer</li> </ul> </li> <li>Error code: -32002</li> <li>Error message: Blocked by 1RPC: invalid address. See https://rules.1rpc.io/002</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32002, \"message\": \"Blocked by 1RPC: invalid address. See https://rules.1rpc.io/002\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"1rpc/1rpcplus/spec/#uniswap-recipient-validation","title":"Uniswap recipient validation","text":"<ul> <li>Rule ID: 003</li> <li>Rule Details: 1RPC+ ensures that the recipient of a Uniswap transaction is the same as the sender of the transaction. In the event of a discrepancy, 1RPC+ will block the transaction.</li> <li>Support networks &amp; contracts<ul> <li>Ethereum Mainnet:<ul> <li>V3 Router: 0xE592427A0AEce92De3Edee1F18E0157C05861564</li> <li>V3 Router2: 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</li> <li>V2 Router: 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a</li> <li>V2 Router2: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D</li> </ul> </li> <li>Polygon Mainnet:<ul> <li>V3 Router: 0xE592427A0AEce92De3Edee1F18E0157C05861564</li> <li>V3 Router2: 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</li> </ul> </li> <li>Optimism:<ul> <li>V3 Router: 0xE592427A0AEce92De3Edee1F18E0157C05861564</li> <li>V3 Router2: 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</li> </ul> </li> <li>Arbitrum One:<ul> <li>V3 Router: 0xE592427A0AEce92De3Edee1F18E0157C05861564</li> <li>V3 Router2: 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</li> </ul> </li> <li>Celo Mainnet:<ul> <li>V3 Router2: 0x5615CDAb10dc425a742d643d949a7F474C01abc4</li> </ul> </li> </ul> </li> <li>Support methods:<ul> <li>V3 Router:<ul> <li>exactInput</li> <li>exactInputSingle</li> <li>exactOutput</li> <li>exactOutputSingle</li> </ul> </li> <li>V3 Router2:<ul> <li>exactInput</li> <li>exactInputSingle</li> <li>exactOutput</li> <li>exactOutputSingle</li> <li>swapExactTokensForTokens</li> <li>swapTokensForExactTokens</li> </ul> </li> <li>V2 Router:<ul> <li>swapExactTokensForTokens</li> <li>swapTokensForExactTokens</li> <li>addLiquidity</li> <li>addLiquidityETH</li> <li>removeLiquidity</li> <li>removeLiquidityETH</li> <li>removeLiquidityWithPermit</li> <li>removeLiquidityETHWithPermit</li> <li>swapETHForExactTokens</li> <li>swapExactETHForTokens</li> <li>swapTokensForExactETH</li> <li>swapExactTokensForETH</li> </ul> </li> <li>V2 Router2:<ul> <li>swapExactTokensForTokens</li> <li>swapTokensForExactTokens</li> <li>addLiquidity</li> <li>addLiquidityETH</li> <li>removeLiquidity</li> <li>removeLiquidityETH</li> <li>removeLiquidityWithPermit</li> <li>removeLiquidityETHWithPermit</li> <li>swapETHForExactTokens</li> <li>swapExactETHForTokens</li> <li>swapTokensForExactETH</li> <li>swapExactTokensForETH</li> <li>removeLiquidityETHSupportingFeeOnTransferTokens</li> <li>removeLiquidityETHWithPermitSupportingFeeOnTransferTokens</li> <li>swapExactETHForTokensSupportingFeeOnTransferTokens</li> <li>swapExactTokensForETHSupportingFeeOnTransferTokens</li> <li>swapExactTokensForTokensSupportingFeeOnTransferTokens</li> </ul> </li> </ul> </li> <li>Error code: -32003</li> <li>Error message: Blocked by 1RPC: recipient is suspicious. See https://rules.1rpc.io/003</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32003, \"message\": \"Blocked by 1RPC: recipient is suspicious. See https://rules.1rpc.io/003\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"1rpc/1rpcplus/spec/#goplus-address-scanning","title":"GoPlus address scanning","text":"<ul> <li>Rule ID: 051</li> <li>Rule Details: 1RPC+ decodes the users' request to obtain addresses that they interact with, and check each of these addresses with Gopluslabs API to verify whether any of them is malicious, By using this rule, users agree to Gopluslabs's Terms of Use.</li> <li>Support methods:<ul> <li>approve</li> <li>setApprovalForAll</li> <li>transferFrom</li> <li>safeTransferFrom</li> <li>transfer</li> </ul> </li> <li>Support networks:<ul> <li>Ethereum Mainnet</li> <li>BNB Smart Chain</li> <li>Polygon Mainnet</li> <li>Fantom Opera</li> <li>Arbitrum One</li> <li>Avalanche</li> </ul> </li> <li>Error code: -32051</li> <li>Error message: Blocked by 1RPC: malicious address. See https://rules.1rpc.io/051</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32051, \"message\": \"Blocked by 1RPC: malicious address. See https://rules.1rpc.io/051\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"1rpc/1rpcplus/spec/#avengerdao-address-scanning","title":"AvengerDAO address scanning","text":"<ul> <li>Rule ID: 052</li> <li>Rule Details: Users can configure a trust level for the accounts that the transaction is going tointeract with. 1RPC+ decodes the users' request to obtain the addresses that the user interacts with. For each of those addresses, 1RPC+ ensures that the trust score based on risk levels provided by AvengerDAO Meter satisfies the threshold specified by the user. By using this rule, users agree to AvengerDAO's Terms of Use.</li> <li>Support methods:<ul> <li>approve</li> <li>setApprovalForAll</li> <li>transferFrom</li> <li>safeTransferFrom</li> <li>transfer</li> </ul> </li> <li>Support networks: BNB Smart Chain</li> <li>Error code: -32052</li> <li>Error message: Blocked by 1RPC: insufficient trust score. See https://rules.1rpc.io/052</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32052, \"message\": \"Blocked by 1RPC: insufficient trust score. See https://rules.1rpc.io/052\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"1rpc/1rpcplus/spec/#explorer-contract-verification","title":"Explorer contract verification","text":"<ul> <li>Rule ID: 053</li> <li>Rule Details: 1RPC+ will decode the transaction and ensure that the target contract address that the user is interacting with is verified on the chain's official explorer. e.g., etherscan for Ethereum. </li> <li>Support networks and their terms of use:<ul> <li>Ethereum mainnet: etherscan.</li> <li>BNB smart chain: bscscan.</li> <li>Polygon mainnet: polygonscan.</li> <li>Arbitrum One: arbiscan.</li> <li>Moonbeam: moonscan.</li> <li>Avalanche: snowtrace.</li> <li>Optimism: optimistic.</li> <li>Fantom Opera: ftmscan.</li> </ul> </li> <li>Error code: -32053</li> <li>Error message: Blocked by 1RPC: unverified contract. See https://rules.1rpc.io/053</li> <li>Example: <pre><code>{\"jsonrpc\": \"2.0\", \"error\": {\"code\": -32053, \"message\": \"Blocked by 1RPC: unverified contract. See https://rules.1rpc.io/053\"}, \"id\": 1}\n</code></pre></li> </ul>"},{"location":"2fa/introduction/","title":"Introduction","text":"<p>2FA Guru by Automata is a blockchain-based authentication solution that secures access to accounts and protects users with an active defence. </p> <p>There are a number of known scenarios where hackers can brute-force attacks: </p> <ul> <li>User-controlled private keys can be compromised or stolen</li> <li>Exploitation of excessive or unlimited ERC20 allowance </li> <li>Rise of social engineering attacks, such as phishing scams </li> </ul> <p>Not all security measures are made equal. 2FA Guru\u2019s secret generation, storage and verification is based on the strongest technical guarantees with Automata\u2019s impenetrable technical design. This makes it nigh-impossible for malicious agents to intercept, obtain, or duplicate the authentication factor. </p>"},{"location":"2fa/introduction/#features","title":"Features","text":"<ul> <li>Anti-phishing protection. Crypto is fun and exciting, but there are serious risks. Make sure your accounts are resistant to real-time identity attacks. </li> <li>Multi-chain support. 2FA Guru is currently live on Polygon mainnet. We\u2019re EVM-compatible and working hard to expand the range of supported networks - If you\u2019d like us to prioritise a chain, submit a proposal here or drop us a message.</li> <li>One-time setup. The additional layer of protection extends across all dApps supported by 2FA Guru on the same blockchain network. </li> <li>Developer-oriented integration. Deploy and secure dApps easily with 2FA Guru\u2019s smart contract. </li> <li>Smooth onboarding. 2FA Guru fits seamlessly into your workflow by working with your favourite tools such as 1Password, LastPass and more. </li> </ul>"},{"location":"2fa/contracts/2FAppendix/","title":"Appendix","text":""},{"location":"2fa/contracts/2FAppendix/#signature-extraction","title":"Signature Extraction","text":"<p>Data that are sent to <code>TwoFactorBase</code> contracts must strictly adhere to the following format.</p> Calldata Deadline Signature dynamically-sized 32 bytes 65 bytes <p>Transaction data that are in compliance with the above format is then divided into three parts using the formula described below:</p> <ul> <li>Deadline = Data [len-97 : len-65]</li> </ul> <p>This is the given deadline of a transaction, which reverts at <code>block.timestamp &gt; deadline</code>.</p> <ul> <li>Signature = Data [-65]</li> </ul> <p>The relayer signature can be simply extracting by slicing out the last 65-bytes of <code>msg.data</code>.</p> <ul> <li>Calldata = Data [0 : len-97]</li> </ul> <p>The actual calldata is the entire <code>msg.data</code> excluding the last 97-byte.</p>"},{"location":"2fa/contracts/2FAppendix/#2fa-message","title":"2FA Message","text":"<p>The message is a hash of the encoded structure, as defined by the following:</p> <pre><code>bytes32 hash = keccak256(\nabi.encode(\nuint256 chainId,\nuint256 walletNonce,\nbytes32 domain_name_hash,\nuint256 deadline,\naddress primary,\naddress target,\nbytes data\n)\n)\n</code></pre> <p>An honest relayer may only sign this message if and only if the relayer is able to verify that the provided 2FA code from the primary wallet holder is valid.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/","title":"TwoFactorAuthentication","text":"<p>The Authenticator contract serves as an on-chain storage for 2FA Guru. It stores information about the list of trusted relayer addresses and the binding between primary and recovery wallets.</p> <p>All 2FA contracts are dependent on the Authenticator contract to perform signature verification. The Authenticator simply returns a boolean type data to determine if a signature is generated from one of the approved relayers.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#getrecoverywallet","title":"<code>getRecoveryWallet</code>","text":"<pre><code>function getRecoveryWallet(address primaryWallet) external view returns (address)\n</code></pre> <p>Gets the address of a recovery wallet based on the given primary wallet address.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#getwalletnonce","title":"<code>getWalletNonce</code>","text":"<pre><code>function getWalletNonce(address primaryWallet) external view returns(uint256)\n</code></pre> <p>Gets the transaction count of the primary wallet.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#validwalletbinding","title":"<code>validWalletBinding</code>","text":"<pre><code>modifier validWalletBinding(address primaryWallet, address recoveryWallet)\n</code></pre> <p>This modifier defines the conditions that both wallets must satisfy to bind with each other. The conditions are:</p> <p>(1) The primary and recovery wallets cannot be the same address</p> <p>(2) The primary wallet can only bind with a recovery wallet once. After a recovery wallet is binded with the primary wallet, this process is not reversible.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#setrecoverywallet","title":"<code>setRecoveryWallet</code>","text":"<pre><code>function setRecoveryWallet(address recoveryWallet) external\n</code></pre> <p>Binds <code>msg.sender</code> with the provided <code>recoveryWallet</code>. This function includes both <code>only2FA</code> and <code>validWalletBinding</code> modifiers.</p> <p> Note: <code>msg.sender</code> is passed as the input to the <code>only2FA</code> modifier. In other words, the primary wallet holder must be the originating caller. This function makes an exception, which delegation is not allowed.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#setrelayer","title":"<code>setRelayer</code>","text":"<pre><code>function setRelayer(address relayerAccount) external\n</code></pre> <p>Adds the given address into a list of vetted relayers. Any signatures signed by <code>relayerAccount</code> will be considered valid after this function is executed. </p> <p>This function requires <code>onlyOwner</code>.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#removerelayer","title":"<code>removeRelayer</code>","text":"<pre><code>function removeRelayer(address relayerAccount) external\n</code></pre> <p>Revokes an existing relayer address from validating 2FAs. Any signatures signed by <code>relayerAddress</code> will no longer be valid after this function is executed.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#istrustedrelayer","title":"<code>isTrustedRelayer</code>","text":"<pre><code>function isTrustedRelayer(address relayerAccount) external view returns (bool)\n</code></pre> <p>Checks whether the provided <code>relayerAccount</code> address is a trusted relayer.</p>"},{"location":"2fa/contracts/TwoFactorAuthentication/#verifysignature","title":"<code>verifySignature</code>","text":"<pre><code>function verifySignature(\nuint256 deadline,\naddress primaryWallet,\naddress target,\nbytes memory data,\nbytes memory signature\n) external returns (bool)\n</code></pre> <p>This function re-constructs and hashes the message to be verified against the provided signature. Returns a boolean value describing whether the provided signature is generated from a trusted relayer.</p> Parameter Type Description deadline <code>uint256</code> The transaction reverts if <code>block.timestamp &gt; deadline</code> primaryWallet <code>address</code> The primary address that is subjected to the 2FA authentication process target <code>address</code> The contract address where the function executes data <code>bytes</code> The calldata to be executed by the target contract signature <code>bytes</code> The signature generated by a relayer <p>See the Appendix section to learn more about the structure of the message that is signed by the relayer.</p>"},{"location":"2fa/contracts/TwoFactorBase/","title":"TwoFactorBase","text":"<p>The base contract is responsible for passing the relayer's signature to be authenticated by the <code>TwoFactorAuthentication</code> contract. The contract then decides to execute or revert a transaction, depending on the data returned by the Authenticator.</p>"},{"location":"2fa/contracts/TwoFactorBase/#constructor","title":"Constructor","text":"<pre><code>constructor (address _authenticator)\n</code></pre> <p>The address of the <code>TwoFactorAuthentication</code> contract is required to be passed onto the constructor, and then stored into the <code>twoFactorAuthenticator</code> variable, which is immutable.</p>"},{"location":"2fa/contracts/TwoFactorBase/#enable2faprotection","title":"<code>enable2FAProtection</code>","text":"<pre><code>function enabled2FAProtection() external\n</code></pre> <p>Sets <code>enabled2FA = true</code>. This method enables 2FA protection for all methods with the <code>only2FA</code> modifier.</p> <p>This method requires <code>onlyOwner</code>.</p>"},{"location":"2fa/contracts/TwoFactorBase/#disable2faprotection","title":"<code>disable2FAProtection</code>","text":"<pre><code>function disabled2FAProtection() external\n</code></pre> <p>Sets <code>enabled2FA = false</code>. Methods with the <code>only2FA</code> modifier are no longer protected.</p> <p>This method requires <code>onlyOwner</code>.</p>"},{"location":"2fa/contracts/TwoFactorBase/#enabled2fa","title":"<code>enabled2FA</code>","text":"<pre><code>function enabled2FA() public view returns(bool)\n</code></pre> <p>Queries the 2FA protection status of the contract.</p>"},{"location":"2fa/contracts/TwoFactorBase/#only2fa","title":"<code>only2FA</code>","text":"<pre><code>modifier only2FA(address primaryWallet)\n</code></pre> <p>Even though the modifier requires the input of a primary wallet address, this does not mean the sender necessarily needs to come from the same address as <code>primaryWallet</code>, as long as the embedded signature is generated by a trusted relayer.</p> <p>Prior to sending a transaction to the contract, the relayer signs a message indicating that the primary wallet holder has provided a valid 2FA code. This signature must be appended into <code>msg.data</code>, which is later sliced out by the <code>only2FA</code> modifier to be sent to the Authenticator contract for verification.</p> <p>See the Appendix section to learn more about the signature extraction process.</p> <p>Read more about <code>TwoFactorAuthentication</code> to learn the signature verification process.</p>"},{"location":"2fa/contracts/summary/","title":"Summary","text":"<p>Smart contracts that benefit from Automata 2FA protection must inherit from the <code>TwoFactorBase</code> contract. Any function calls that require 2FA protection must include the <code>only2FA</code> modifier.</p> <p>2FA Guru relies on the <code>TwoFactorAuthentication</code> contract to: </p> <ul> <li>(1) store the mapping between primary and recovery wallets, and </li> <li>(2) verifies the authenticity of the transaction based on the provided signature from the relayer. </li> </ul> <p>The binding between a primary wallet and the recovery wallet is subjected to the usual 2FA workflow, as the Authenticator contract itself also extends the <code>TwoFactorBase</code> contract. After a user has completed the binding process, they can easily query their recovery wallet address by providing their primary wallet address.</p> <p>Read the next section to learn more about the <code>TwoFactorBase</code> contract.</p>"},{"location":"2fa/developers/faq/","title":"Frequently Asked Questions","text":""},{"location":"2fa/developers/faq/#1-how-can-i-integrate-my-dapp-with-the-automatas-2fa-protection","title":"1. How can I integrate my dApp with the Automata's 2FA protection?","text":"<p>You can refer to the smart contract section for more technical details. Do ensure that all asset transfer operation include a only2FA modifier.</p>"},{"location":"2fa/developers/workflow/","title":"Workflow","text":"<ul> <li>Make your authorised transfer</li> </ul> <pre><code>sequenceDiagram\n  autonumber\n    participant PW as Primary wallet\n    participant Client as 2FA client\n    participant DApp as Automata 2FA Guru\n    participant Geode as 2FA Guru Geode\n    participant Contract as Target contract\n\n  note over PW, DApp: Make authorised transfer\n  PW-&gt;&gt;DApp: Attempt to transfer 2FA protected assets\n  DApp--&gt;&gt;PW: Request 2FA code and recipient address\n  PW-&gt;&gt;Client: Acquire a valid 2FA code\n  Client--&gt;&gt;PW: 6-digit 2FA code\n  PW-&gt;&gt;DApp: Input the valid 2FA code and recipient address\n  DApp-&gt;&gt;Geode: Ask for the validation\n  alt\n    note over Geode: Validation succeeded\n    Geode--&gt;&gt;DApp: Return a signature based on the actual transaction\n    DApp--&gt;&gt;PW: Metamask signature\n    PW-&gt;&gt;DApp: Make authorised transfer\n    DApp-&gt;&gt;Contract: Make authorised transfer\n  else\n    note over Geode: Validation failed\n    Geode--&gt;&gt;DApp: Return a validation error\n    DApp--&gt;&gt;PW: Request declined\n  end</code></pre> <ul> <li>Recover your 2FA client</li> </ul> <pre><code>sequenceDiagram\n  autonumber\n    participant RW as Recovery Wallet\n    participant Client as 2FA client\n    participant DApp as Automata 2FA Guru\n    participant Geode as 2FA Guru Geode\n    participant Contract as 2FA authentication contract\n\n  RW-&gt;&gt;DApp: Attempt to recover your 2FA client for your primary wallet\n  DApp-&gt;&gt;Geode: Ask for the validation\n  Geode-&gt;&gt;Contract: Check the binding relationship\n  alt\n    note over Geode: Validation succeeded\n    Geode--&gt;&gt;DApp: Return a new generated secret\n    DApp--&gt;&gt;Client: Scan the QR code to set up\n    Client-&gt;&gt;DApp: Input a 6-digit 2FA code\n    DApp-&gt;&gt;Geode: Confirm reset\n    alt\n      note over Geode: Validation succeeded\n      Geode-&gt;&gt;DApp: Reset succeeded\n    else\n      note over Geode: Validation failed\n      Geode-&gt;&gt;DApp: Return a validation error\n    end\n  else\n    note over Geode: Validation failed\n    Geode--&gt;&gt;DApp: Request declined\n  end</code></pre>"},{"location":"2fa/developers/workflow/#key-components","title":"Key Components","text":"<ul> <li>Primary wallet:</li> </ul> <p>The wallet where users store and control their assets.</p> <ul> <li>Recovery wallet:</li> </ul> <p>Used for identifying users' roles and resetting the 2FA device. The relationship between the primary wallet and the recovery wallet is saved on-chain after binding.</p> <ul> <li>2FA client:</li> </ul> <p>The device which provides the TOTP(Time-based one-time password).</p> <ul> <li>Automata 2FA Guru</li> </ul> <p>The dApp hosted by the Automata team. It contains the 2FA management and wallet assets control panels. Users can sign up for 2FA and find the 2FA protected dApps in the management panel. They can also make authorised transfers under the wallet assets control panel.</p> <ul> <li>2FA Guru Geode: </li> </ul> <p>The 2FA middleware which is built upon the Intel SGX. With the provision of a secure, fully-shielded enclave, the platform connects seamlessly with dApps to provide support for 2FA verification on public blockchains. It's responsible for the 2FA secret generation, storage and authentication. Attackers cannot predict or calculate the valid signature outside the enclave, and its storage is encrypted internally and attackers are unable to view anything even if they managed to steal data.</p> <p>Even though the assets are safe under the 2FA protection, it's still possible for attackers to steal the TOTP by using a phishing attack. To prevent this, we use an anti-phishing feature where our 2FA middleware can analyse the original domain and detect whether it's coming from the phishing domains or links by using daily updated phishing blacklists. If a malicious domain is detected, the geode will not provide a signature to keep users' assets safe. To uphold high security standards, we also support a custom domain whitelist for a specified dApp.</p>"},{"location":"2fa/users/faq/","title":"Frequently Asked Questions","text":""},{"location":"2fa/users/faq/#1-are-the-2fa-secrets-different-for-each-account","title":"1. Are the 2FA secrets different for each account?","text":"<p>Of course. Each new account has a unique secret, which is replaced if a reset request is confirmed. Even with the same account, secrets are different across networks.</p>"},{"location":"2fa/users/faq/#2-how-long-does-it-take-to-bind-a-recovery-wallet","title":"2. How long does it take to bind a recovery wallet?","text":"<p>Binding takes place immediately. You will need to bind a recovery wallet within 7 days of signing up with your primary wallet. </p>"},{"location":"2fa/users/faq/#3-how-long-does-it-take-to-disable-2fa","title":"3. How long does it take to disable 2FA?","text":"<p>Once you have put in your request, there is a cooldown window of 7 days before 2FA is permanently disabled for that particular account. During those 7 days, if you happen to change your mind, simply cancel the request.</p>"},{"location":"2fa/users/faq/#4-can-i-change-my-recovery-wallet-after-binding","title":"4. Can I change my recovery wallet after binding?","text":"<p>Unfortunately, no. Binding is permanent, so make sure to keep your recovery wallet safe - for one, don't use it in the same device as your primary wallet so that they are not compromised at the same time. </p>"},{"location":"2fa/users/faq/#5-during-the-setup-process-what-happens-if-i-scan-the-qr-code-without-inputting-the-6-digit-authentication-code","title":"5. During the setup process, what happens if I scan the QR code without inputting the 6-digit authentication code?","text":"<p>2FA will not be successfully enabled for the account, and the authenticated code from its secret will not be authorized.</p>"},{"location":"2fa/users/faq/#6-during-the-reset-process-what-if-i-scan-the-qr-code-without-inputting-the-6-digit-authentication-code","title":"6. During the reset process, what if I scan the QR code without inputting the 6-digit authentication code?","text":"<p>The new secret will not be stored in the 2FA storage. The user's old secret will remain active.</p>"},{"location":"2fa/users/faq/#7-can-i-use-the-same-recovery-wallet-for-more-than-one-primary-wallet","title":"7. Can I use the same recovery wallet for more than one primary wallet?","text":"<p>Yes.</p>"},{"location":"2fa/users/faq/#8-what-kinds-of-assets-will-be-shown-in-the-wallet-assets-management-page","title":"8. What kinds of assets will be shown in the wallet assets management page?","text":"<p>All 2FA protected assets and Top20 ERC20 tokens in each network.</p> <ul> <li>Polygon: https://polygonscan.com/tokens</li> </ul>"},{"location":"2fa/users/guide/","title":"User Guide","text":""},{"location":"2fa/users/guide/#how-to-setup","title":"How to setup","text":"<ul> <li>Head to 2FA Guru</li> <li>Connect your Metamask wallet </li> <li>If this is your first time using 2FA Guru, click on <code>Wallet Actions</code> to sign up</li> <li>Sign a message to prove your identity before a unique 2FA secret is generated </li> <li>Your primary wallet and 2FA device should be on two separate devices </li> </ul> <ul> <li>2FA Guru is compatible with numerous authenticators which can store the 2FA secret</li> <li>This includes 1Password, LastPass, Authy, and more</li> </ul> <p>Recommended configuration in 1Password</p> username wallet address website https://app.2fa.guru tags the target network <ul> <li>We recommend linking a recovery wallet so that you are able to reset the 2FA anytime</li> <li>There is a window of 7 days after signing up for users to complete this step</li> <li>To set up a recovery wallet, send a binding transaction to 2FA management contract. Gas fees are required</li> </ul> <p></p> <p></p>"},{"location":"2fa/users/guide/#reset-2fa-device","title":"Reset 2FA device","text":"<ul> <li>In the event that a user has lost access to the 2FA application or device, reset is only possible when a recovery wallet has been linked</li> <li>The process is straightforward and similar to the first-time set up for 2FA Guru </li> <li>Head to 2FA Guru</li> <li>Connect your recovery wallet using Metamask</li> <li>Click on <code>Reset 2FA</code> under <code>Wallet Actions</code></li> <li>Provide the primary wallet address and sign the message</li> <li>A match between the address pair will allow the user to scan a new secret</li> <li>The 2FA device is successfully reset. No gas fees are required </li> </ul>"},{"location":"2fa/users/guide/#make-authorised-transfers","title":"Make authorised transfers","text":"<ul> <li>Once 2FA Guru has been set up, all assets across supported dApps will enjoy the same protection</li> <li>These assets can be transferred under the <code>Manage my wallet assets</code> panel</li> <li>Users will have to sign a message in order to secure the transfer </li> </ul>"},{"location":"2fa/users/guide/#disable-2fa-protection","title":"Disable 2FA protection","text":"<ul> <li>After a user has disabled 2FA, there is a cooldown period of 7 days during which the request can be cancelled</li> <li>Once the request has been confirmed after 7 days, the user will not be able to use 2FA Guru again </li> </ul>"},{"location":"2fa/users/guide/#steps-to-disable-2fa","title":"Steps to disable 2FA","text":"<ul> <li>Head to 2FA Guru</li> <li>Connect your wallet using Metamask</li> <li>Click on <code>Disable 2FA</code> button under <code>Wallet actions</code></li> <li>After signing the message, there is a cooldown window of 7 days during which the request can be cancelled</li> <li>2FA Guru remains active during this period and assets will continue to be protected </li> </ul> <ul> <li>To cancel the disable request, click on <code>Cancel Disable 2FA</code> under <code>Wallet Actions</code></li> </ul>"},{"location":"anydao/design/","title":"Design","text":""},{"location":"anydao/design/#architecture","title":"Architecture","text":"<p>AnyDAO MVP is composed of 4 major components:</p> <ul> <li>Substrate based blockchain: Stores the related metadata and proofs for Projects and Proposals.</li> <li>IPFS: Stores actual data such as texts, images and public voter information.</li> <li>Geode: Receives, queries and aggregates user votes. Also monitors the on-chain status and handles the uploading of IPFS storage and on-chain storage. At the same time, it ensures the protection of user privacy.</li> <li>Frontend: Gathers all kinds of data and provides information via graphical interface, and provides interactivity for users to register projects, create proposals, cast votes and many more.</li> </ul>"},{"location":"anydao/design/#concept","title":"Concept","text":""},{"location":"anydao/design/#project","title":"Project","text":"<p>Represents the DAO. The creator is the default owner, and has the right to update project settings, as well as transfer the ownership to another address.</p>"},{"location":"anydao/design/#workspace","title":"Workspace","text":"<p>Each project can configure multiple workspaces. Each workspace is composed of a chain and strategies</p>"},{"location":"anydao/design/#strategy","title":"Strategy","text":"<p>Defines how to get the voting power of users from on-chain states, such as by calculating ERC20 token balance</p>"},{"location":"anydao/design/#proposal","title":"Proposal","text":"<p>Represents a topic where user can vote on with their assets</p>"},{"location":"anydao/design/#snapshot","title":"Snapshot","text":"<p>To ensure fairness and avoid double-entry, a snapshot mechanism is adopted in our design. When a proposal is started, the block height of each participating chain will be taken by our Geode, and the state of each user will be fetched for power aggregation.</p>"},{"location":"anydao/design/#privacy-level","title":"Privacy Level","text":"<p>There are currently 4 levels of privacy settings: - Public: Details of all individual votes made by users will be made available. - Private: Total amount of votes for each option will be made available as an aggregation while the individual vote is hidden. - Mixed: Users have the option to choose to reveal their vote or to cast their vote in the form of an aggregated result. - Opaque: Only the result of the vote is revealed. All other details are hidden, including the aggregated vote amount.</p>"},{"location":"anydao/design/#update-frequency","title":"Update Frequency","text":"<ul> <li>Stands for how often Geode executes transaction to update the on-chain state.</li> <li>The total number of updates for a proposal is calculated by the total voting duration divided by update frequency.</li> <li>Each execution generates a transaction fee and the proposal creator is responsible for this payment.</li> <li>If the update frequency is not enabled, Geode will only update the IPFS and on-chain state when the proposal is ended.</li> </ul>"},{"location":"anydao/guide/","title":"User Guide","text":""},{"location":"anydao/guide/#claim-test-tokens","title":"Claim test tokens","text":"<ul> <li>This guide assumes you have set up your wallet account. If not, please refer here</li> <li>Head to the Automata Faucet. You may need to login via a Twitter account</li> <li>Choose ContextFree under the Network drop-down field </li> <li>Input your ContextFree wallet address and click Submit</li> <li>10 CTX tokens will be sent to your account. You can also check this on our dashboard</li> </ul>"},{"location":"anydao/guide/#interface-layout","title":"Interface layout","text":"<ul> <li>Let's take a look at the AnyDAO frontend </li> <li>The left panel contains the directory</li> <li>The right panel displays all projects currently registered on AnyDAO</li> </ul>"},{"location":"anydao/guide/#connect-wallet","title":"Connect wallet","text":"<ul> <li>The connect button is located at the bottom of the left panel</li> <li>To disconnect, click on your connected wallet to locate the Disconnect button</li> <li>Connect with a PolkadotJS wallet to carry out the following: <code>Register Project</code>, <code>Update Project</code>, and <code>Create Proposal</code></li> </ul>"},{"location":"anydao/guide/#create-project","title":"Create project","text":"<ul> <li>Having followed the steps above, <code>Project Management</code> should appear on the left panel. Make sure you are connected with a Polkadot Extension Wallet </li> <li>Go to <code>Project Management</code>, then <code>Add a new project</code> </li> <li>Fill in your project title and description</li> <li>Upload your project icon, as well as banner</li> <li>Add workspaces for your project and select the chain </li> <li>Select a strategy from the drop-down menu </li> <li>You should arrive at this page once done  </li> <li>Click on <code>Submit new project</code> and follow the wallet instructions to submit the transaction. Ensure your wallet has enough tokens to pay for the transaction fee </li> <li>A message should appear which means your project has been created successfully </li> </ul>"},{"location":"anydao/guide/#update-project","title":"Update Project","text":"<ul> <li>Upon successfully creating your project, you should be able to see it under <code>Project Management</code> </li> <li>Select a project that has been created previously </li> <li>Adjust your settings. Once you're done, click on <code>Save project settings</code>. </li> <li>Follow the wallet instructions to submit the transaction. </li> </ul>"},{"location":"anydao/guide/#create-proposal","title":"Create Proposal","text":"<ul> <li>Click on <code>New Proposal</code> </li> <li>Fill in a title and short description  </li> <li>Click on <code>Define proposal configurations</code> to adjust your settings  </li> <li>Understand the different privacy levels</li> <li>Understand the different voting types</li> <li>Starting date &amp; ending date refers to the proposal voting period. Understand more about time restriction</li> <li>Understand more about update frequency</li> <li>Click on <code>Publish my proposal</code> and follow the instructions to submit your transaction. You should be able to see your proposal once it has been successfully created </li> </ul>"},{"location":"anydao/guide/#vote","title":"Vote","text":"<ul> <li>Go to any on-going proposal or one you have just created </li> <li>For proposals with <code>Mixed</code> privacy level, toggle <code>Vote Privacy</code> to choose whether to vote publicly or anonymously  </li> <li>Choose to vote publicly and details of the vote will be visible, such as:   </li> <li>Choose to vote anonymously and no details will be revealed</li> <li>Click on an option to cast your vote</li> <li>Voting only requires a signature from your wallet. No fees will be charged for voting</li> <li>You can use either Metamask wallet or Polkadot Extension Wallet according to the project's workspace configuration</li> </ul> <p>This is an example of a closed proposal</p>"},{"location":"anydao/introduction/","title":"Introduction","text":""},{"location":"anydao/introduction/#overview","title":"Overview","text":"<p>Governance is a perennial issue that has taken on weighted importance with the considerable growth of blockchain protocols, with many of these networks boasting billions in locked value on their platforms. Be that as it may, participation rate remains low. One of the most immediate challenges for most Web3 projects on the path of decentralization is in figuring out the tangle of collective decision making.</p> <p>AnyDAO is designed with powerful, intutiive tools to help make this happen. </p>"},{"location":"anydao/introduction/#features","title":"Features","text":"<ul> <li>Borderless governance  Vote aggregation across different blockchain networks (and token standards)</li> <li>Multi-chain platform  Native support for DAOs on EVM and Substrate-based platforms </li> <li>Zero-cost voting  Free (gasless!) to create and vote on proposals with signed messages</li> <li>Multi-tier privacy   Adjustable privacy settings which controls the visibility of the voting results</li> <li>Custom parameters  Voting can be done through NFTs, LP tokens or native Substrate account balances</li> </ul>"},{"location":"anydao/spec/","title":"Specifications","text":""},{"location":"anydao/spec/#production","title":"Production","text":""},{"location":"anydao/spec/#frontend","title":"Frontend","text":"<p>https://the.anydao.app/</p> <p>Currently supports wallet connection with Metamask and Polkadot Extension</p>"},{"location":"anydao/spec/#faucet","title":"Faucet","text":"<p>https://faucet.ata.network</p>"},{"location":"anydao/spec/#blockchain","title":"Blockchain","text":""},{"location":"anydao/spec/#explorer","title":"Explorer","text":"<p>ContextFree Dashboard</p>"},{"location":"anydao/spec/#endpoints","title":"Endpoints","text":"<p>https://cf-rpc.ata.network"},{"location":"anydao/spec/#configurations","title":"Configurations","text":"<ul> <li>Minimum voting period: 1 hour</li> <li>Maximum voting period: 30 days</li> <li>Maximum option count: 10</li> <li>Maximum workspace number: 10</li> <li>Maximum strategy number: 10</li> </ul>"},{"location":"anydao/spec/#supported-chains","title":"Supported Chains","text":"Platform Protocol Automata Mainnet Substrate ContextFree Canary Network Substrate FiniteState Testnet Substrate Ethereum Mainnet EVM Ropsten Testnet EVM Kovan Testnet EVM BSC Mainnet EVM BSC Testnet EVM Polygon Mainnet EVM Polygon Testnet EVM HECO Mainnet EVM HECO Testnet EVM Moonbase Alpha Testnet EVM Avalanche Testnet EVM Avalanche Mainnet EVM"},{"location":"anydao/spec/#strategies","title":"Strategies","text":""},{"location":"anydao/spec/#evm","title":"EVM","text":"Name Parameter Description ERC20Balance Contract Address Take <code>BalanceOf</code> as voting power"},{"location":"anydao/spec/#substrate","title":"Substrate","text":"Name Parameter Description NativeBalance - Take <code>System/Account</code> and the <code>Free</code> balance as voting power"},{"location":"anydao/spec/#voting-type","title":"Voting Type","text":"Name Parameter Description SingleChoice - User can vote on only one option"},{"location":"canarynet/getstarted/introduction/","title":"ContextFree Network","text":"<p>ContextFree is the Canary Network of Automata\u2019s Mainnet, and this is an important milestone in realizing the technological vision of a privacy middleware platform built for Web 3.0.</p> <p>The launch of ContextFree provides a pre-production environment for real-life learnings to be applied to the eventual rollout of the Mainnet. During this time, users are invited to battle-test the code. Features are rolled out in phases to ensure the stability and security of the blockchain.</p> <p>This documentation homepage offers the necessary resources to learn about ContextFree, guides and tools to contribute to the Canary Network, either as a user looking to explore the blockchain, or to participate by running a node. Here are some background information to get you started:</p>"},{"location":"canarynet/getstarted/introduction/#network-parameters","title":"Network Parameters","text":""},{"location":"canarynet/getstarted/introduction/#basic","title":"Basic","text":"Config Parameter Expected block time 6 seconds Epoch duration 4 hours Era duration 24 hours Account prefix 11820"},{"location":"canarynet/getstarted/introduction/#tokens","title":"Tokens","text":"<p>CTX are ContextFree tokens, and do not have any monetary value. Users can request for free CTX tokens by heading over to our faucet. The initial circulation amount of CTX is set at 1 billion, and will be minted on demand.</p>"},{"location":"canarynet/getstarted/introduction/#roadmap","title":"Roadmap","text":"<p>ContextFree launch progress mimics and follows the Roadmap, with faster iteration. All upgrades will be recorded in this documentation.</p>"},{"location":"canarynet/getstarted/introduction/#features","title":"Features","text":"2021-09-30 Initial launch ContextFree was launched on September 30, 2021, in Proof of Authority mode. All nodes are held by the Automata team, with most functionalities disabled.  2021-10-09 Token Economics Features related to Transfer, Staking and Token Bridge have been enabled on October 9, 2021.  2021-10-12 NPoS Nominated Proof of Stake has been enabled on October 12, 2021, and public validators will be able to join the network."},{"location":"canarynet/getstarted/introduction/#resources","title":"Resources","text":"Name Value Dashboard https://dashboard.ata.network HTTP RPC Endpoint https://cf-rpc.ata.network Websockets RPC Endpoint wss://cf-api.ata.network"},{"location":"canarynet/node/node-type/","title":"Type of Nodes","text":"<p>Before an introduction to the distinct type of nodes, it is important to understand a few concepts: * Genesis block: defined by a chain spec file, which describes the initial status of a chain, including the initial wasm, balances, authority set and so on. * Extrinsics: a piece of information that comes from outside the chain and is included in a block, which will change the state of chain. * Events: a piece of information comes from inside the chain, which may trigger some operation and change the state of chain.</p> <p>The chain starts from a initial state, and updated by Extrinsics or Events. Assume the current block height is N, a validator will takes the chain state at block N and apply changes on top of it, to construct the block N+1.</p>"},{"location":"canarynet/node/node-type/#archive-node","title":"Archive node","text":"<p>Archive Nodes keeps all the historical state in storage. So it is convenient to use a archive node to query the state of a certain block height. For example, you can get the balance of <code>Alice</code> at block 20, or get the validator number at block 1024. As a result, running a archive node needs more disk space. Generally, archive nodes are used when you need to know the past states.</p>"},{"location":"canarynet/node/node-type/#full-node","title":"Full node","text":"<p>Full nodes keeps states of genesis block and serveral recently blocks in storage. By default, blocks which is older than 256 from the latest finalized block will be discarded. Besides, full node keeps extrinsics for all past blocks, so it can rebuild the chain without additional information. Full nodes need less disk space than archive node and is used when you just want to read the recently state of chain, submit or validate extrinsics.</p> <p>For running full node or archive node, please refer here.</p>"},{"location":"canarynet/node/node-type/#light-node","title":"Light node","text":"<p>Light nodes has only the runtime and current state, does not keep any of the historical state or extrinsics. Light nodes are useful for resource limited devices.</p>"},{"location":"canarynet/node/node-type/#validator","title":"Validator","text":"<p>Validator is a special kind of archive node. Like archive nodes, validators keep all the historical state in storage. More importantly, validators are participants of the chain, which are responsible for validate blocks, voting for finality and so on. Validators will be rewarded for maintaining the chain and slashed for misbehavior.</p> <p>For running validator node, please refer here.</p>"},{"location":"canarynet/node/run-full-node/","title":"Run Full Node","text":""},{"location":"canarynet/node/run-full-node/#introduction","title":"Introduction","text":"<p>According to description in Type of Nodes, you can run Full Node, Archive Node or Validator Node on ContextFree Network. In this section, we briefly introduce how to run <code>Full Node</code> or <code>Archive Node</code> For running <code>Validator Node</code>, please refer to the next section.</p>"},{"location":"canarynet/node/run-full-node/#preparation","title":"Preparation","text":""},{"location":"canarynet/node/run-full-node/#dependencies","title":"Dependencies","text":"<ul> <li>Install Docker</li> <li>Please go to this link to download the docker engine for your Operating System accordingly.</li> </ul>"},{"location":"canarynet/node/run-full-node/#create-a-local-directory-to-store-the-chain-data","title":"Create a Local Directory To Store the Chain Data","text":"<ul> <li>You may need <code>sudo</code> permission to run the following commands.</li> <li>Firstly create a folder to store the synchronized on-chain data     <pre><code>mkdir /chain\n</code></pre></li> <li>Change the ownership and permission of your local storage directory to current user     <pre><code>sudo chown -R $(id -u):$(id -g) /chain\n</code></pre></li> </ul>"},{"location":"canarynet/node/run-full-node/#launch-node","title":"Launch Node","text":""},{"location":"canarynet/node/run-full-node/#launch-full-node","title":"Launch Full Node","text":"<ul> <li>Run the following command to launch a Full Node, you may need <code>sudo</code> permission:   <pre><code>  docker run -it \\\n  -v \"/chain:/data\" \\\n  -u $(id -u ${USER}):$(id -g ${USER}) \\\n  -d \\\n  atactr/automata:contextfree-v0.1.0-rc4 \\\n  --node-type full \\\n  --name &lt;YOUR_NODE_NAME&gt;\n</code></pre></li> <li>Which will return the c_ontainer ID of your node</li> <li><code>&lt;YOUR_NODE_NAME&gt;</code> can be anything, but it's recommended to have something unique to make it easier to identify your node.</li> </ul>"},{"location":"canarynet/node/run-full-node/#launch-archive-node","title":"Launch Archive Node","text":"<ul> <li>Run the following command to launch a Archive Node, you may need <code>sudo</code> permission:     <pre><code>docker run -it \\\n-v \"/chain:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n-d \\\natactr/automata:contextfree-v0.1.0-rc4 \\\n--node-type archive \\\n--name &lt;YOUR_NODE_NAME&gt;\n</code></pre></li> <li>Which will return the container ID of your node</li> <li><code>&lt;YOUR_NODE_NAME&gt;</code> can be anything, but it's recommended to have something unique to make it easier to identify your node.</li> </ul>"},{"location":"canarynet/node/run-full-node/#check-launch-status","title":"Check Launch Status","text":"<ul> <li>Check whether your node downloading blocks by checking the logs   <pre><code>docker logs --follow &lt;YOUR_CONTAINER_ID&gt;\n</code></pre></li> <li> <p>If it works fine, the beginning of the log should look like </p> </li> <li> <p>Take note of your node identity behind <code>\"Local node identity is: ...\"</code>. This will be very important for identifying your node on the Telemetry, as the node name can be duplicated.</p> </li> <li>Notice that you should have a non-zero number of <code>\"peers\"</code> connected as shown in the image above.</li> <li>If the logs saying <code>\"Error while dialing /dns/...\"</code>, don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.</li> </ul>"},{"location":"canarynet/node/run-validator/","title":"Run A Validator","text":""},{"location":"canarynet/node/run-validator/#introduction","title":"Introduction","text":"<p>You may want to run a validator, which means if you are elected into the validator set, you will be able to earn rewards. To run a validator, you need to run a validator node and stake some tokens, we will show you how to do it step by step.</p>"},{"location":"canarynet/node/run-validator/#steps","title":"Steps","text":""},{"location":"canarynet/node/run-validator/#install-dependencies","title":"Install Dependencies","text":"<ul> <li>Install Docker</li> <li>Please go to this link to download the docker engine for your Operating System accordingly.</li> </ul>"},{"location":"canarynet/node/run-validator/#create-a-local-directory-to-store-the-chain-data","title":"Create a Local Directory To Store the Chain Data","text":"<ul> <li>You may need <code>sudo</code> permission to run the following commands.</li> <li>Firstly create a folder to store the synchronized on-chain data     <pre><code>mkdir /chain\n</code></pre></li> <li>Change the ownership and permission of your local storage directory to current user     <pre><code>sudo chown -R $(id -u):$(id -g) /chain\n</code></pre></li> </ul>"},{"location":"canarynet/node/run-validator/#launch-the-validator-node","title":"Launch the Validator Node","text":"<ul> <li>Run the following command to launch a validator node, you may need <code>sudo</code> permission:   <pre><code>docker run -it \\\n-v \"/chain:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\n-d \\\natactr/automata:contextfree-v0.1.0-rc4 \\\n--node-type validator \\\n--name &lt;YOUR_NODE_NAME&gt;\n</code></pre></li> <li>Which will return the container ID of your node</li> <li><code>&lt;YOUR_NODE_NAME&gt;</code> can be anything, but it's recommended to have something unique to make it easier to identify your node.</li> </ul>"},{"location":"canarynet/node/run-validator/#check-launch-status","title":"Check Launch Status","text":"<ul> <li>Check whether your node downloading blocks by checking the logs   <pre><code>docker logs --follow &lt;YOUR_CONTAINER_ID&gt;\n</code></pre></li> <li> <p>If it works fine, the beginning of the log should look like </p> </li> <li> <p>Take note of your node identity behind <code>\"Local node identity is: ...\"</code>. This will be very important for identifying your node on the Telemetry, as the node name can be duplicated.</p> </li> <li>Notice that you should have a non-zero number of <code>\"peers\"</code> connected as shown in the image above.</li> <li>If the logs saying <code>\"Error while dialing /dns/...\"</code>, don't be panic, normally it may take a few minutes for the node to connect to the Telemetry server, after that the error will stop popping up.</li> </ul>"},{"location":"canarynet/node/run-validator/#get-session-keys-of-your-node","title":"Get Session Keys Of Your Node","text":"<ul> <li>Run the following command</li> <li>Install <code>curl</code> in your docker container:     <pre><code>docker exec -t -u root &lt;YOUR_CONTAINER_ID&gt; bash -c 'apt-get update | apt-get -y install curl'\n</code></pre></li> <li>Fetch Session Keys from your container:     <pre><code>docker exec -t &lt;YOUR_CONTAINER_ID&gt; curl http://127.0.0.1:9933 -H \"Content-Type:application/json;charset=utf-8\" -d '{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"method\":\"author_rotateKeys\",\n    \"params\": []\n}'\n</code></pre></li> <li>You will get a response like this   <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\":\"0xc05a9d093e4db4c1bde31977716e7a0a39d6f3d1f1bf749e7fec8371147de730af6860aeef81a11130c9fcd317b96e736f6c36141c28f382a18f9faf6e7df797eaa951ead00d12db10937003f0956e3d3444d1774d452ed045dbc1b84d1bf1471abf5d77bf5033845f01be1188a852c6f0ba703042b4d06d14314841c1096c50\",\n  \"id\":1\n}\n</code></pre></li> <li>The content after <code>\"result\"</code> is the session keys of your validator node</li> </ul>"},{"location":"canarynet/node/run-validator/#set-up-accounts","title":"Set Up Accounts","text":"<ul> <li>For running a validator, you need to set up two accounts:</li> <li><code>Stash account</code>: This account holds funds bonded for staking, but delegates some functions to the Controller account. It can be kept in a cold wallet, meaning it can stays offline all the time.</li> <li><code>Controller account</code>: This account acts on behalf of the Stash account, signalling decisions and necessary execution for staking. It only needs enough funds to pay transaction fees.</li> <li>For more details, refer to Polkadot Keys.</li> <li>For how to create accounts in ContextFree, you can refer here.</li> </ul>"},{"location":"canarynet/node/run-validator/#get-token","title":"Get Token","text":"<ul> <li>Your Stash account and Controller account need to be funded with some native token</li> <li>If you already had some native token on other account, you can simply transfer to the stash and controller accounts you have created, using the dashboard by opening the <code>Transfer</code> page under the <code>Accounts</code> tab.</li> <li>If you don't have any native token, visit Get Token from Faucet to get some native token.</li> <li>Alternatively, if you have some ContextFree ERC20 token, you can follow the Token Bridge user guide to convert it into native token.</li> </ul>"},{"location":"canarynet/node/run-validator/#stake-tokens","title":"Stake Tokens","text":"<ul> <li>Visit the Automata Dashboard</li> <li>Go to the <code>Staking</code> section. </li> <li>Set Stash and Controller. </li> <li>Choose the stash account and controller account accordingly, set the value for staking and press <code>Bond</code> to submit the transaction. </li> </ul>"},{"location":"canarynet/node/run-validator/#set-session-keys","title":"Set Session Keys","text":"<ul> <li>Click <code>Session Keys</code> and set the session keys you got previously. </li> <li>If you are nominating someone, you need to stop nominating or you will not be able to set session keys.</li> </ul>"},{"location":"canarynet/node/run-validator/#set-validate-parameters","title":"Set Validate Parameters","text":"<ul> <li>Click <code>Validate</code> </li> <li>Set the value of <code>reward commission percentage</code>, which is the rate that your validator will be commissioned with. The remaining rewards will be split among your nominators. </li> <li>Besides, you can choose to accept nominating or not.</li> </ul>"},{"location":"canarynet/node/run-validator/#joining-validator-set","title":"Joining Validator Set","text":"<ul> <li>If you go to the \"Staking\" tab, you will see a list of active validators currently running on the network. At the top of the page, it shows the number of validator slots that are available as well as the number of nodes that have signaled their intention to be a validator. You can go to the \"Waiting\" tab to double check to see whether your node is listed there. </li> <li>The validator set is refreshed every era. In the next era, if there is a slot available and your node is selected to join the validator set, your node will become an active validator. Until then, it will remain in the waiting queue. If your validator is not selected to become part of the validator set, it will remain in the waiting queue until it is. There is no need to re-start if you are not selected for the validator set in a particular era. However, it may be necessary to increase the number of native token staked or seek out nominators for your validator in order to join the validator set.</li> </ul>"},{"location":"canarynet/node/run-validator/#congratuation","title":"Congratuation","text":"<p>If you have followed all of these steps, and been selected to be a part of the validator set, you are now running a ContextFree validator!</p>"},{"location":"canarynet/userguide/accounts/","title":"Accounts","text":"<p>This document introduce you to the basics of ContextFree accounts.</p>"},{"location":"canarynet/userguide/accounts/#account-basic","title":"Account basic","text":"<p>The address format used in ContextFree network is SS58, which is a modification of Base-58-check from Bitcoin with some miner changes. More details can be found on the Substrate github wiki.</p> Network Address type prefix Leading characters Example(Alice) Automata Network 2349 aA ContextFree Network 11820 a7 a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8 FiniteState Network 13107 at ateYGxACWo2Yu8wVi7RGJQsEQLAB25xbAHkSRpzTqMabJ38zx Substrate default 42 5 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY <p>As we known, the secret seed of account Alice is: <code>0xe5be9a5092b81bca64be81d212e7f2f9eba183bb7a90954f7b76361f6edb5c0a</code>. In ContextFree network, the address of Alice will be <code>a7SvTrjvshEMePMEZpEkYMekuZMPpDwMNqfUx8N8ScEEQYfM8</code>. But all addresses above are merely different representations of the same public key in a private-public keypair. In another word, the account in ContextFree network is compatible with other substrate-based chains.</p>"},{"location":"canarynet/userguide/accounts/#create-account","title":"Create account","text":"<p>There are several ways to create an ContextFree account, we will suggest you to use our official blockchain explorer.</p>"},{"location":"canarynet/userguide/accounts/#create-account-using-explorer","title":"Create account using explorer","text":"<ol> <li>Open official blockchain explorer of Automata, check the connected network on the left upper corner of web page. If the connected network is not ContextFree Network, click and choose Automata ContextFree in TEST NETWORKS. </li> <li>Click Accounts in the top menu and choose Accounts, you will enter the accounts page. Then click Add account and start to create a new account. </li> <li>You will see a auto generated mnemonic in the popup box, please copy this mnemonic and save it safely. </li> <li>Enter an alias for this account and create a password, we suggest you to use a strong and unique password. </li> <li>Click Save and we finish the process of creating an account. </li> <li>The newly created account will be show in the list, and there will be a auto downloaded file which describe the details of this account. </li> </ol>"},{"location":"canarynet/userguide/accounts/#import-existing-account","title":"Import existing account","text":"<p>The process of importing an existing account into blockchain explorer is similar to the process of creating one. We will show you how to import the well known Alice account. 1. Override the auto generated Mnemonic or Raw seed with mnemonic or seed of your existing account.  2. Create an alias and enter the password, the imported account will be show in the list. </p>"},{"location":"canarynet/userguide/accounts/#wallet","title":"Wallet","text":"<p>Please refer to Wallet tutorial if you want to create and manage accounts in polkadot extention.</p>"},{"location":"canarynet/userguide/get-test-token/","title":"Get Test Token","text":"<p>This is a guide on how to claim test token on the ContextFree</p> <ul> <li>Assume you have set up your wallet account, if not, please refer to here</li> </ul>"},{"location":"canarynet/userguide/get-test-token/#use-automata-faucet","title":"Use Automata Faucet","text":"<ul> <li>Visit the Automata Faucet, you may need to login via Twitter account to get access to the faucet page.</li> </ul>"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-native-token","title":"Get ContextFree Native Token","text":"<ul> <li>Input your canary network wallet address under this tab, and press <code>Submit</code>. </li> <li>Then 10 CTX native token will be sent to your address, you can check on the Automata Dashboard.</li> <li>Notice: You can request funding for your address for once per 24 hours.</li> </ul>"},{"location":"canarynet/userguide/get-test-token/#get-contextfree-erc20-token-on-ropsten-testnet","title":"Get ContextFree ERC20 Token on Ropsten Testnet","text":"<ul> <li>Input your Ropsten ETH address under this tab, and press <code>Submit</code>. </li> <li>Then 10 CTX ERC20 token will be sent to your Ropsten address, you can check on Ropsten Explorer.</li> <li>However the ERC20 token cannot be utilized as native token on the canary network, you can follow the instruction here to use the Automata Token Bridge to convert it into the ContextFree native token.</li> <li>Notice: You can request funding for your address for once per 24 hours.</li> </ul>"},{"location":"canarynet/userguide/setupwallet/","title":"ContextFree Network Wallet Setup Guide","text":"<p>This is a guide on how to get onto the Automata Canary Net for Chrome users(recommended). </p> <ol> <li> <p>Go to 'ContextFree Dashboard' You should reach a website which looks like the picture below. </p> </li> <li> <p>Hover over the Accounts taskbar and click on Accounts. Picture showing what is needed to be clicked. You should then reach this page. </p> </li> <li> <p>Then you must click on the link called polkadot-js extension on the page.  This will direct you to an extension which needs to be downloaded. You should then add this to chrome. </p> </li> <li> <p>You must then click on the plugin to create an account. This process is very easy and just requires you to record your seed phrase, which should be noted to ensure you have a way to restore control of your account, create a username and then a password. You will then have an account. The account should look like this in the plugin. </p> </li> <li> <p>Once you have created your account, it will be necessary to refresh your page on Dashboard.ata.network. This will then prompt you to authorise polkadot{.js}, which you should approve. What the Authorize prompt looks like. </p> </li> <li> <p>After you have allowed the application access, you should then click on the settings tab at the top of the screen. Click on Settings.  Then click on Metadata.  Then click on update metadata.  This will give you another prompt from polkadot{.js} asking to add the metadata to your extension instance. Click \u2018yes, do this metadata update\u2019 </p> </li> <li> <p>After you have done this, click on the polkadot{.js} plugin again. After this click on the three dots next to your account, click on the drop down box which currently says \u2018Allow Use On Any Chain\u2019 and change it to \u2018ContextFree Network.\u2019  After you have done this, refresh your page and click on Accounts again. If there is no exclamation mark next to your account then everything should be set up correctly. It should look like this.  However, if there is an exclamation mark, then ensure that you have followed all the steps above. If you believe you have done all the steps properly, try the whole process once more and if you are still having problems then get in touch with us. If you have problems it would look like this. </p> </li> </ol> <p>Now that you have set up everything, complete our google form with your name, email, Discord username, Telegram handle and your ContextFree Network wallet address and we will airdrop you some $CTX tokens for you to take part in the upcoming Canary Games. </p> <p>To participate in the Canary Games, register now with this form.</p>"},{"location":"canarynet/userguide/token-bridge/","title":"Automata ContextFree Token Bridge Tutorial","text":""},{"location":"canarynet/userguide/token-bridge/#introduction","title":"Introduction","text":"<p>A cross-chain bridge is a connection that allows the transfer of tokens from one chain to another. Both chains can have different protocols and rules, but the bridge provides a compatible way to interoperate securely on both sides.  The Automata team has set up a cross-chain token bridge for ContextFree between EVM (Ropsten testnet) and Substrate-based chains(ContextFree canary network) by adopting one of the currently available solutions ChainBridge built by ChainSafe.</p>"},{"location":"canarynet/userguide/token-bridge/#tutorial","title":"Tutorial","text":""},{"location":"canarynet/userguide/token-bridge/#transfer-erc20-token-to-native-token","title":"Transfer ERC20 Token to Native Token","text":""},{"location":"canarynet/userguide/token-bridge/#preparation","title":"Preparation","text":"<ul> <li>To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed:</li> <li> <p>Metamask Wallet Extension</p> </li> <li> <p>Visit Automata Token Bridge.</p> </li> </ul>"},{"location":"canarynet/userguide/token-bridge/#set-up-metamask","title":"Set Up MetaMask","text":"<ul> <li>Click <code>Connect with Ethereum Wallet(ERC20 -&gt; Native)</code>. </li> <li>Select <code>MetaMask</code>. </li> <li>Then you may need may need to enter password to unlock the MetaMask wallet extension if it hasn't been open for a while.</li> <li>Connect Metamask to bridge dapp. </li> <li>Change the network in MetaMask to <code>Ropsten Test Network</code>. </li> <li>If you don't see the CTX token showing up in the assets, press <code>Import tokens</code>, enter the following specifications and press <code>Add Custom Token</code>: </li> <li>Token Contract Address: <code>0x8289b901CAC48EbBB1B5cb0049d1459EA1240EF7</code></li> <li>Token Symbol: <code>CTX</code></li> <li>Token Decimal: <code>18</code> </li> <li>Then <code>Import Tokens</code>, if you already had some CTX token, the balance will be showed.</li> <li>Let's go back to the web page for the token bridge, by now it should look like this:    If not you can click <code>Connect</code> and repeat the above steps.</li> </ul>"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app","title":"Use the Bridge App","text":"<ul> <li>Make sure the following fields are correct:</li> <li>Home network: <code>Ethereum Ropsten</code>.</li> <li>Destination Network: <code>Automata ContextFree</code>.</li> <li>Get some CTX ERC20 token if the balance is 0, please refer here.</li> <li>Make sure you have enough <code>ETH</code> on Ropsten Testnet to pay for the BridgeFee and transaction Gas Fee. If not, you can use Ropsten Ethereum Faucet to get some airdrop.</li> <li>Enter the amount of CTX you want to transfer.</li> <li>For the Destination Address, make sure that:</li> <li>the address starts with <code>a7</code>.</li> <li>the address is valid by trying Add Contact on Automata Dashboard.</li> <li>double check the destination address is correct, once your token were sent to a wrong address it can never be claimed back.</li> <li>If everything looks okay, press <code>Start transfer</code>, confirm the <code>Pre-flight check</code> and press <code>Start Transfer</code> again.</li> <li>Then a MetaMask notification will be popped up to let you allow the website to spend your CTX token, press <code>Confirm</code>. Wait a moment for that transaction to be confirmed. </li> <li>Another MetaMask notification will be prompted, which is to send a transaction to trigger the actual cross-chain bridging transfer, press <code>Confirm</code>.</li> <li>Then you should be able to see this <code>In Transit</code>, it usually takes a few minutes to finish the transferring, please be patient. </li> <li> <p>Once the transferring has been completed, it will show <code>Transfer completed</code> </p> </li> <li> <p>Congratulations! You have completed your first cross-chain token transfer on Automata ContextFree!   Go check the balance of the destination address on Automata Dashboard. If you can't see it, try <code>Add contact</code> in the Address book.</p> </li> </ul>"},{"location":"canarynet/userguide/token-bridge/#transfer-native-token-to-erc20-token","title":"Transfer Native Token to ERC20 Token","text":""},{"location":"canarynet/userguide/token-bridge/#preparation_1","title":"Preparation","text":"<ul> <li>To use the Automata Token Bridge, please ensure your explorer is Chrome and the following is installed:</li> <li> <p>Polkadot{.js} Wallet Extension</p> </li> <li> <p>Visit Automata Token Bridge.</p> </li> </ul>"},{"location":"canarynet/userguide/token-bridge/#set-up-polkadotjs","title":"Set Up Polkadot{.js}","text":"<ul> <li>Click <code>Connect with Substrate Wallet(Native -&gt; ERC20)</code>. </li> <li>If it's your first time to use ContextFree bridge, you need to allow it to access your wallet. </li> <li>Authorize the application to access the wallet by pressing <code>Yes, allow this application access</code> on the popped up Polkadot.js notification.</li> <li>If you haven't set up your wallet addresses, please refer here.</li> </ul>"},{"location":"canarynet/userguide/token-bridge/#use-the-bridge-app_1","title":"Use the Bridge App","text":"<ul> <li>After connecting you Substrate wallet and setting up your Polkadot.js wallet extension, the Token Bridge App should be like this: </li> <li>Click <code>Select an account</code>, you should be able to see a list of addresses starting with <code>a7</code>, which are ContextFree addresses injected from your Polkadot.js wallet extension. </li> <li>Select the address you want to transfer native token from, the page now should look like: </li> <li>Make sure the following fields are correct:</li> <li>Select account: The address of your native token sender.</li> <li>Destination Network: <code>Ethereum Ropsten</code>.</li> <li>Get some native CTX test token if the balance is 0, please refer here.</li> <li>Make sure you have enough balance to pay for the Bridge Fee and the total amount to transfer.</li> <li>Fill in the <code>Destination Address</code>, which will be an Ethereum address on Ropsten Test Network starting with <code>0x</code>.</li> <li>Press <code>Start transfer</code>, you will be required to input the password to sign the transaction.</li> <li>Wait for your transfer to complete, it may take a few minutes. </li> <li>After the webpage showing <code>Transfer completed</code>. You can go to Ethereum Ropsten Explorer to check the balance of ContextFree ERC20 Token of your destination address.</li> </ul>"},{"location":"conveyor/overview/","title":"Overview","text":""},{"location":"conveyor/overview/#overview","title":"Overview","text":"<p>Automata Conveyor is a MEV Minimization solution that enforces fair ordering of transactions. The front-running-free-zone that ensures users are not disavantaged by overpaying on their transactions. </p> <p>Because blockchains are written by consensus and the content of each block is chosen by block producers - miners in PoW and validators in PoS systems - there is room and frankly, great incentive, for them to profit by front-running, back-running, sandwiching and generally exploiting transactions in their block. This is what is referred to as Maximal Extractable Value (MEV). </p>"},{"location":"conveyor/overview/#how-it-works","title":"How it works","text":"<p>When transactions are fed into Conveyor, the service ingest and outputs incoming transactions by a FIFO order. This means block producers cannot: </p> <ul> <li>Inject new transactions into the Conveyor output. Any inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch.</li> <li>Delete ordered transactions. Transactions accepted by Conveyor are broadcasted throughout the network so transactions cannot be deleted unless all block producers are colluding and censoring the transactions at the same time.</li> </ul>"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/","title":"Controller","text":"<p>The prevention of anti-front-running is implemented by requiring that all method calls to the DEX must be only invoked by the Geode. The user submits a request to the Geode by signing the message without spending gas. The Geode later delegates that request to the DEX for a fee that is deducted from the output token.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#constructor","title":"<code>constructor()</code>","text":"<pre><code>constructor(address _relayer,address _router,address _factory);\n</code></pre> <p>Initializes the Controller, Uniswap Factory, and Router contracts and assigns a relayer.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayers","title":"<code>relayers</code>","text":"<pre><code>mapping (address =&gt; bool) public relayers;\n</code></pre> <p>Key-value pair map that keeps track of the trusted relayers.</p> Parameter Type key <code>address</code> Input address value <code>bool</code> <code>True</code>: address is a trusted relayer. <code>False</code> : otherwise"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2trustedpair","title":"<code>uniswapV2TrustedPair</code>","text":"<pre><code>mapping (address =&gt; bool) public uniswapV2TrustedPair;\n</code></pre> <p>Key-value pair map that keeps track of the trusted Uniswap token pair addresses.</p> Parameter Type key <code>address</code> Input address value <code>bool</code> <code>True</code>: address is a trusted pair. <code>False</code> : otherwise"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#relayeronly","title":"<code>relayerOnly()</code>","text":"<pre><code>modifier relayerOnly();\n</code></pre> <p>Verifies <code>msg.sender</code> is a trusted relayer address, otherwise reverts the function call.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#setrelayer","title":"<code>setRelayer()</code>","text":"<pre><code>function setRelayer(address _relayer) public onlyOwner()\n</code></pre> <p>Assigns the input address as a trusted relayer, can only be invoked by the contract owner.</p> Parameter Type _relayer <code>address</code> Input address"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#istrusteduniswapv2pair","title":"<code>isTrustedUniswapV2Pair()</code>","text":"<pre><code>function isTrustedUniswapV2Pair(address pair) external override returns (bool);\n</code></pre> <p>Checks the input address to determine whether it is a trusted Uniswap pair address or not, returns <code>bool</code>.</p> Parameter Type pair <code>address</code> Input address"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#addtrusteduniswapv2pair","title":"<code>addTrustedUniswapV2Pair()</code>","text":"<pre><code>function addTrustedUniswapV2Pair(address pair) public onlyOwner();\n</code></pre> <p>Adds the input address as a trusted Uniswap pair address, can only be invoked by the contract owner.</p> Parameter Type pair <code>address</code> Input address"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#removetrusteduniswapv2pair","title":"<code>removeTrustedUniswapV2Pair()</code>","text":"<pre><code>function removeTrustedUniswapV2Pair(address pair) public onlyOwner();\n</code></pre> <p>Removes the pair address from the <code>uniswapV2TrustedPair</code> map, can only be invoked by the contract owner.</p> Parameter Type pair <code>address</code> Input address"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#gtokentransferfrom","title":"<code>gTokenTransferFrom()</code>","text":"<pre><code>function gTokenTransferFrom(\naddress asset,\naddress from,\naddress to,\nuint256 amount\n) public relayerOnly();\n</code></pre> <p>Transfers ERC20 tokens from a sender address to a recipient address, can only be invoked by a relayer.</p> Parameter Type asset <code>address</code> The address of the ERC20 token from <code>address</code> Sender address to <code>address</code> Recipient address amount <code>uint256</code> Amount of tokens to be transferred"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2addliquidity","title":"<code>uniswapV2AddLiquidity()</code>","text":"<pre><code>function uniswapV2AddLiquidity(\naddress from,\naddress tokenA,\naddress tokenB,\nuint256 amountADesired,\nuint256 amountBDesired,\nuint256 amountAMin,\nuint256 amountBMin,\naddress to,\nuint256 deadline,\nbool gasIsTokenA\n) public relayerOnly();\n</code></pre> <p>This method initially checks for either token A or B balance (depending on <code>gasIsTokenA</code>), to make sure that the user could pay for gas. Then, deducts the token amount, which is transferred to the relayer.</p> <p>Supplies the token pair to the Uniswap liquidity pool, can only be invoked by a relayer and input tokens must be both wrapped tokens. Any leftover tokens that are not added to the liquidity pool will be refunded to the sender.</p> Parameter Type from <code>address</code> The sender address tokenA <code>address</code> Wrapped Token A address tokenB <code>address</code> Wrapped Token B address amountADesired <code>uint256</code> The amount of A added to the liquidity pool if the B/A price &lt;= (<code>amountofBDesired</code> / <code>amountofADesired</code>) price amountBDesired <code>uint256</code> The amount of B added to the liquidity pool if the A/B price &lt;= (<code>amountofADesired</code> / <code>amountofBDesired</code>) price amountAMin <code>uint256</code> Bounds the extent to which the B/A price can go up before the transaction reverts. Must be &lt;= <code>amountADesired</code> amountBMin <code>uint256</code> Bounds the extent to which the A/B price can go up before the transaction reverts. Must be &lt;= <code>amountBDesired</code> to <code>address</code> The recipient address of the liquidity token. In this project, it is most likely the sender's address, since they provided liquidity, they should be entitled to getting rewarded with liquidity tokens deadline <code>uint256</code> Unix timestamp after which the transaction is reverted gasIsTokenA <code>bool</code> User to pay gas in Token A or Token B"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swapexacttokensfortokens","title":"<code>uniswapV2SwapExactTokensForTokens()</code>","text":"<pre><code>function uniswapV2SwapExactTokensForTokens(\naddress from,\nuint256 amountIn,\nuint256 amountOutMin,\naddress[] calldata path,\naddress to,\nuint256 deadline\n) public relayerOnly();\n</code></pre> <p>This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer.</p> <p>Swaps an exact amount of input tokens for as much of output tokens as possible, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender.</p> Parameter Type from <code>address</code> The sender address amountIn <code>uint256</code> The amount of input tokens to be sent amountOutMin <code>uint256</code> The minimum amount of tokens that must be received, otherwise the transaction reverts path <code>address[]</code> An array of token addresses. <code>path.length &gt;= 2</code> to <code>address</code> Recipient of the output tokens. In this project, it is also the sender's address deadline <code>uint256</code> Unix timestamp after which the transaction is reverted"},{"location":"conveyor/conveyorv1/automata-conveyor-controller/#uniswapv2swaptokensforexacttokens","title":"<code>uniswapV2SwapTokensForExactTokens()</code>","text":"<pre><code>function uniswapV2SwapTokensForExactTokens(\naddress from,\nuint256 amountIn,\nuint256 amountOutMin,\naddress[] calldata path,\naddress to,\nuint256 deadline\n) public relayerOnly();\n</code></pre> <p>This method initially checks for the balance of the input token, to make sure that the user could pay for gas. Then after the swapping of tokens, deducts the output token amount, which is transferred to the relayer.</p> <p>Swaps an amount of input tokens for exact amount of output tokens, can only be invoked by a relayer. Any leftover tokens that are not swapped will be refunded to the sender.</p> Parameter Type from <code>address</code> The sender address amountInMax <code>uint256</code> The minimum amount of tokens that must be sent, otherwise the transaction reverts amountOut <code>uint256</code> The amount of output tokens to be sents path <code>address[]</code> An array of token addresses. <code>path.length &gt;= 2</code> to <code>address</code> Recipient of the output tokens. In this project, it is also the sender's address deadline <code>uint256</code> Unix timestamp after which the transaction is reverted"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/","title":"gToken","text":"<p>The goal of gTokens is to achieve front-running resistance on DEXs such as Uniswap. When two different gTokens are swapped, users can rest assured that the swapping transaction will not be attacked by front-running bots or malicious miners. This is achieved by inheriting the ERC20 contract, with modified function methods. Methods such as <code>transferFrom()</code> requires that it has to be invoked only from a trusted relayer.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#constructor","title":"<code>constructor()</code>","text":"<pre><code>   constructor(address _token, address _controller);\n</code></pre> <p>Initializes the contract, then wraps the ERC20 token and assigns the <code>Controller</code> contract instance.</p> Parameter Type _token <code>address</code> The ERC20 Token Address _controller <code>address</code> The address of the <code>Controller</code> instance"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#onlycontroller","title":"<code>onlyController()</code>","text":"<pre><code>modifier onlyController();\n</code></pre> <p>Verifies <code>msg.sender</code> is the Controller address. Otherwise, reverts function calls.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#setcontroller","title":"<code>setController()</code>","text":"<pre><code>function setController(address _controller) public onlyOwner();\n</code></pre> <p>Sets the Controller instance, can only be invoked by the contract owner.</p> Parameter Type _controller <code>address</code> The address of the Controller instance"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transferfrom","title":"<code>transferFrom()</code>","text":"<p><pre><code>function transferFrom(\naddress sender, address recipient, uint256 amount\n) public override returns (bool);\n</code></pre> Transfers gTokens from a given address to the recipient. The sender is always the address of the <code>Controller</code>, the transaction is not necessarily originated from the <code>Controller</code> contract itself, as long as the origin address is one of the trusted relayers. For the direct call method, see <code>internalTransferFrom()</code>.</p> Parameter Type sender <code>address</code> The address of a trusted relayer recipient <code>address</code> The recipient's address, most likely a token pair address. For example, an address returned by Uniswap's <code>getPair(tokenA, tokenB)</code>. amount <code>uint256</code> The amount of token to be transferred. <p>This method reverts if it is not invoked from a trusted relayer. Otherwise, returns true.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#transfer","title":"<code>transfer()</code>","text":"<pre><code>function transfer(address recipient, uint256 amount) public override returns (bool);\n</code></pre> <p>Transfers gTokens to a recipient. This method can only be invoked by a trusted token pair.</p> Parameter Type recipient <code>address</code> The recipient's address amount <code>uint256</code> The amount of token to be transferred"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#internaltransferfrom","title":"<code>internalTransferFrom()</code>","text":"<pre><code>function internalTransferFrom(\naddress sender,\naddress recipient,\nuint256 amount\n) public onlyController();\n</code></pre> <p>Transfers gTokens from a given address to the recipient, similar to <code>transferFrom()</code>. This method can only be invoked directly from the <code>Controller</code> contract.</p> Parameter Type sender <code>address</code> The sender's address recipient <code>address</code> The recipient's address amount <code>uint256</code> The amount of token to be transferred"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#deposit","title":"<code>deposit()</code>","text":"<pre><code>function deposit(uint256 amount) public;\n</code></pre> <p>Wraps ERC20 token to a gToken. The gToken smart contract stores an amount of ERC20 token as a reserve and mints the same amount of wrapped ERC20 token.</p> Parameter Type amount <code>uint256</code> The amount of token to be transferred"},{"location":"conveyor/conveyorv1/automata-conveyor-gtoken/#withdraw","title":"<code>withdraw()</code>","text":"<pre><code>function withdraw(uint256 amount) public;\n</code></pre> <p>Withdraws ERC20 token from the smart contract and burns the wrapped token.</p> Parameter Type amount <code>uint256</code> The amount of token to be transferred"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/","title":"Overview","text":"<p>Automata Conveyor is an anti-front-running service that ingests and outputs transactions in a determined order.</p> <p>Automata Conveyor currently has the following components:</p> <ul> <li> <p>gToken smart contract: inherits the ERC20 contract with modified function methods that must be invoked by trusted Geode-provided addresses.</p> </li> <li> <p>Controller smart contract: interacts with the users and facilitates the transfer of gTokens. External calls to any functions in the contract from any addresses other than the trusted relayers will be reverted.</p> </li> <li> <p>Automata Conciliator: TBA</p> </li> </ul> <p>The following is an overview of the architecture.</p> <p></p> <p>Note</p> <p>The Geode is an on-chain computation resource provided by the Automata network.</p>"},{"location":"conveyor/conveyorv1/automata-conveyor-overview/#smart-contract-call-graph","title":"Smart Contract Call Graph","text":"<p>The following call graph details the interaction among smart contracts.</p> <p></p>"},{"location":"conveyor/conveyorv1/fee-contract/","title":"<code>Fee.sol</code>","text":"<p>The contract fetches real-time price feed from Chainlink Oracles and converts the gas fee amount to an equivalent token price.</p>"},{"location":"conveyor/conveyorv1/fee-contract/#admin","title":"<code>admin</code>","text":"<p><pre><code>mapping(address =&gt; bool) admins;\n</code></pre> Key-value pair map that keeps track of the contract admin.</p> Parameter Type key <code>address</code> input addresses value <code>bool</code> <code>True:</code> the address is an admin, <code>False:</code> otherwise"},{"location":"conveyor/conveyorv1/fee-contract/#pricecontracts","title":"<code>priceContracts</code>","text":"<p><pre><code>mapping(bytes =&gt; address) public priceContracts;\n</code></pre> Key-value pair map that stores the address of a Chainlink pricefeed oracle contract.</p> Parameter Type key <code>bytes</code> The input price feed index, with the format: <code>&lt;network&gt;-&lt;token&gt;-eth</code>. For example, to query the USDC/ETH price from the Mainnet, enter <code>main-usdc-eth</code> value <code>address</code> The Chainlink oracle address"},{"location":"conveyor/conveyorv1/fee-contract/#tokensmap","title":"<code>tokensMap</code>","text":"<p><pre><code>mapping(address =&gt; bytes) public tokensMap;\n</code></pre> Key-value pair mapping tokens to their contract addresses.</p> Parameter Type key <code>address</code> The ERC20 token address value <code>bytes</code> The input price feed index, as defined in <code>priceContracts</code>"},{"location":"conveyor/conveyorv1/fee-contract/#constructor","title":"<code>constructor()</code>","text":"<p><pre><code>constructor() public;\n</code></pre> Assigns the deployer as a default admin, and pre-assigns the following price feed:</p> <ul> <li><code>main-usdc-eth</code></li> <li><code>main-uni-eth</code></li> <li><code>kovan-usdc-eth</code></li> </ul>"},{"location":"conveyor/conveyorv1/fee-contract/#onlyadmin","title":"<code>onlyAdmin()</code>","text":"<p><pre><code>modifier onlyAdmin();\n</code></pre> Verifies <code>msg.sender</code> is a contract admin.</p>"},{"location":"conveyor/conveyorv1/fee-contract/#modifyadmin","title":"<code>modifyAdmin()</code>","text":"<p><pre><code>function modifyAdmin(address input, bool isAdmin) public onlyAdmin();\n</code></pre> Adds or removes admin privilege to or from the input address.</p> Parameter Type input <code>address</code> The input address to be given or revoked admin privilege isAdmin <code>bool</code> <code>true</code>: assigns admin, <code>false</code>: revokes admin"},{"location":"conveyor/conveyorv1/fee-contract/#addpricefeed","title":"<code>addPriceFeed()</code>","text":"<p><pre><code>function addPriceFeed(\nstring memory priceIndex, address feed, address token\n) public onlyAdmin();\n</code></pre> Adds a new price feed, then maps to the token address. It can only be invoked by an admin. To find more oracle addresses, check out the Chainlink docs.</p> Parameter Type priceIndex <code>string</code> The input price feed index, as defined in <code>priceContracts</code> feed <code>address</code> The address of the Chainlink price feed token <code>address</code> The ERC20 token address"},{"location":"conveyor/conveyorv1/fee-contract/#gasprice","title":"<code>gasPrice()</code>","text":"<p><pre><code>function getPrice(address token) public view returns (int256);\n</code></pre> Gets the real time price data from Chainlink in 18 decimals.</p> Parameter Type token <code>address</code> The ERC20 Token address"},{"location":"conveyor/conveyorv1/fee-contract/#calculategasintokens","title":"<code>calculateGasInTokens()</code>","text":"<p><pre><code>function calculateGasInTokens(\naddress token, uint256 gas, uint256 weiPerToken\n) public view returns (uint256)\n</code></pre> Returns the amount of tokens equivalent to the gas fee.</p> Parameter Type token <code>address</code> The ERC20 token address gas <code>uint256</code> The gas fee weiPerToken <code>uint256</code> The Wei amount per token"},{"location":"conveyor/conveyorv1/fee/","title":"Fee System","text":""},{"location":"conveyor/conveyorv1/fee/#overview","title":"Overview:","text":"<p>1)   The user submits a request to the Geode to perform a transaction. For example, swapping 100 gUSDC for 100 gDAI. <code>swapExactTokensForTokens()</code></p> <p>Transitioning to Step 2: The Geode verifies that the amount of input token (USDC) is sufficient to pay for gas. The Geode can do this by simply calling the <code>getPrice()</code> method from <code>Fee.sol</code> to get USDC/ETH price in 18 decimals. For example, 1 USDC = 0.000361 ETH would yield 361000000000000. </p> <p>After Geode confirmed the user meets the minimum fee requirement, see step 2.</p> <p>2)   The Geode estimates the gas limit and the gas price. The <code>Controller</code> would capture this information to perform another input token check on step 3.</p> <p>3)    After the <code>Controller</code> finalizes the gas fee check, the <code>Controller</code> sends the transaction to <code>UniswapRouter02</code> to perform the swap. The Geode would pay the gas fee \"out of pocket\" here, to be reimbursed later on step 4. Then, calculates the actual amount of gas consumption at this point.</p> <p>4)   Let's say the fast gas price is 49 gWei, with an average gas limit of 200,000 to perform a swap, the total gas fee (at the time of writing this) is 0.0098 ETH. The <code>Controller</code> then automatically allocates 25.48 gDAI to reimburse the Geode (or locks it in the contract itself). The user gets the remaining 74.52 gDAI.</p>"},{"location":"conveyor/conveyorv1/fee/#price-feed-oracles-that-are-available-on-chainlink","title":"Price Feed oracles that are available on Chainlink","text":"<p>Click here to find the oracle addresses for the following exchange rates.</p>"},{"location":"conveyor/conveyorv1/fee/#ethereum-mainnet","title":"Ethereum Mainnet","text":"<ul> <li>1INCH / ETH</li> <li>AAVE / ETH</li> <li>ALPHA / ETH</li> <li>AMPL / ETH</li> <li>ANT / ETH</li> <li>BADGER / ETH</li> <li>BAL / ETH</li> <li>BAND / ETH</li> <li>BAT / ETH</li> <li>BNB / ETH</li> <li>BNT / ETH</li> <li>BTC / ETH</li> <li>BUSD / ETH</li> <li>BZRX / ETH</li> <li>CEL / ETH</li> <li>COMP / ETH</li> <li>COVER / ETH</li> <li>CREAM / ETH</li> <li>CRO / ETH</li> <li>CRV / ETH</li> <li>DAI / ETH</li> <li>DPI / ETH</li> <li>ENJ / ETH</li> <li>FIL / ETH</li> <li>FTM / ETH</li> <li>FTT / ETH</li> <li>GRT / ETH</li> <li>HEGIC / ETH</li> <li>HUSD / ETH</li> <li>KNC / ETH</li> <li>KP3R / ETH</li> <li>LINK / ETH</li> <li>LON / ETH</li> <li>LRC / ETH</li> <li>MANA / ETH</li> <li>MKR / ETH</li> <li>MLN / ETH</li> <li>MTA / ETH</li> <li>NMR / ETH</li> <li>OCEAN / ETH</li> <li>OGN / ETH</li> <li>OMG / ETH</li> <li>ORN / ETH</li> <li>PAX / ETH</li> <li>PAXG / ETH</li> <li>PERP / ETH</li> <li>RAI / ETH</li> <li>RARI / ETH</li> <li>REN / ETH</li> <li>REP / ETH</li> <li>RGT / ETH</li> <li>RLC / ETH</li> <li>RUNE / ETH</li> <li>SFI / ETH</li> <li>SNX / ETH</li> <li>SRM / ETH</li> <li>SUSD / ETH</li> <li>SUSHI / ETH</li> <li>TUSD / ETH</li> <li>UMA / ETH</li> <li>UNI / ETH</li> <li>USDC / ETH</li> <li>USDT / ETH</li> <li>UST / ETH</li> <li>WNXM / ETH</li> <li>WOM / ETH</li> <li>YFI / ETH</li> <li>YFII / ETH</li> <li>ZRX / ETH</li> </ul>"},{"location":"conveyor/conveyorv2/design/","title":"ConveyorV2 Design","text":""},{"location":"conveyor/conveyorv2/design/#summary","title":"Summary","text":"<p>ConveyorV2 is an upgrade of Automata's ConveyorV1 to support a better user experience.  Tokens that are traded in the ConveyorV2 liquidity pools enjoy the MEV protection and transaction ordering enforcement capabilities without the need to wrap existing ERC20 tokens into gTokens.</p> <p>Similar with ConveyorV1 (formerly known as GTokens), users must sign an EIP712 message to authorize Geode to submit a transaction on the user's behalf. Users would still enjoy the benefit of gasless trading, meaning they are not required to hold native tokens like MATIC or BNB to pay for gas.  However, users are subjected to pay a service fee with an acceptable form of ERC20 tokens, such as DAI, USDC or ATA tokens.</p>"},{"location":"conveyor/conveyorv2/design/#codebase","title":"Codebase","text":"<p>The ConveyorV2 smart contracts are a fork of UniswapV2. To learn more about the DEX protocol, read the UniswapV2 docs.</p> <p>There are certain modifications applied to the contracts. Check out the next section for details.</p>"},{"location":"conveyor/conveyorv2/design/#comparison-between-the-uniswapv2-protocol-and-conveyorv2","title":"Comparison between the UniswapV2 Protocol and ConveyorV2","text":"<p>This section highlights the modification that has been applied to the DEX protocol contracts.</p>"},{"location":"conveyor/conveyorv2/design/#conveyorv2pair","title":"ConveyorV2Pair","text":"<ul> <li>The addition of the <code>onlyRouter()</code> modifier. This modifier guards the <code>mint()</code>, <code>burn()</code> and <code>swap()</code> methods, such that it is made callable by the Router contract only. This modifier is the most viable for enforcing MEV protection, because it prevents any other addresses from bypassing our relayers to perform sandwich attacks.</li> </ul>"},{"location":"conveyor/conveyorv2/design/#conveyorv2factory","title":"ConveyorV2Factory","text":"<ul> <li>The <code>router()</code> address variable, the <code>ConveyorV2Pair</code> contract uses this value to match with the caller address. If the caller address does not match with <code>router()</code>, then the pair contract rejects the transaction. Using this approach also allows the \"upgradeability\" of the router. After the deployment of a newer version of the Router contract, the owner of the DEX can invoke the <code>setRouter()</code> method to map it to the new router address. At this point, all existing pair contracts would only accept function calls from the new Router contract.</li> </ul>"},{"location":"conveyor/conveyorv2/design/#conveyorv2router01","title":"ConveyorV2Router01","text":"<ul> <li> <p>The ConveyorV2 router introduces the ability for gasless trading. The user signs the EIP712 message, which is then submitted to the trusted relayer. The trusted relayer then executes the <code>executeMetaTx()</code> method, and pays gas on the user's behalf. After completion of execution, the Forwarder contract collects a service fee from the user to compensate for gas. Check out the <code>ERC20Forwarder</code> section to learn more about the Forwarder contract.</p> </li> <li> <p>In an unlikely event when the relayer service is not available, the protocol owner can disable the meta-transaction functionality by invoking the <code>metaSwitch()</code> method to toggle the <code>metaOnly</code> modifier. This would allow users to directly interact with the router contract as a temporary workaround for such an extenuating circumstance.</p> </li> </ul>"},{"location":"conveyor/conveyorv2/design/#erc20-forwarder","title":"ERC20 Forwarder","text":"<p>The gas forwarder contract enables meta-transaction executions, which allows gas relayers to be compensated for the gas payment with ERC20 tokens. The gas forwarder contract has the ability to calculate a better estimation of the actual gas usage, including transactions that are being reverted. This way, the relayers are only compensated for the equivalent amount of ERC20 token in gas usage.</p> <p></p>"},{"location":"conveyor/conveyorv2/design/#constructor","title":"<code>constructor()</code>","text":"<p>Initializes the contract and assigns <code>msg.sender</code> as the default <code>feeHolder</code>. The <code>feeHolder</code> is the recipient of the ERC20 fee payment.</p>"},{"location":"conveyor/conveyorv2/design/#setconstantfee","title":"<code>setConstantFee()</code>","text":"<pre><code>function setConstantFee(uint256 _newConstantFee) public onlyOwner\n</code></pre> <p>Updates the <code>constantFee</code> value, defaults at 21000. Requires <code>owner()</code> privilege.</p> Parameter Type _newConstantFee <code>uint256</code> constant gas limit value"},{"location":"conveyor/conveyorv2/design/#settransferfee","title":"<code>setTransferFee()</code>","text":"<pre><code>function setTransferFee(uint256 _newTransferFee) public onlyOwner\n</code></pre> <p>Updates the ERC20 transfer gas limit, the <code>transferFee</code> value, defaults at 65000. Requires <code>owner()</code> privilege.</p> Parameter Type _newTransfeFee <code>uint256</code> ERC20 transfer limit value"},{"location":"conveyor/conveyorv2/design/#setrelayer","title":"<code>setRelayer()</code>","text":"<pre><code>function setRelayer(address _relayer, bool _trusted) public onlyOwner\n</code></pre> <p>Assigns or revokes relayer role. Requires <code>owner()</code> privilege.</p> Parameter Type _relayer <code>address</code> Relayer address _trusted <code>bool</code> True: grant authorization; false: revoke authorization"},{"location":"conveyor/conveyorv2/design/#setfeeholder","title":"<code>setFeeHolder()</code>","text":"<pre><code>function setFeeHolder(address _feeHolder) public onlyOwner\n</code></pre> <p>Transfers <code>feeHolder</code> role over to the input address. Requires <code>owner()</code> privilege.</p> Parameter Type _feeHolder <code>address</code> Fee holder address"},{"location":"conveyor/conveyorv2/design/#metatransaction","title":"<code>MetaTransaction</code>","text":"<pre><code>struct MetaTransaction {\naddress from;\naddress feeToken;\nuint256 maxTokenAmount;\nuint256 deadline;\nuint256 nonce;\nbytes data;\nbytes32 hashedPayload;\n}\n</code></pre> Parameter Type from <code>address</code> the user's address feeToken <code>address</code> The address of the ERC20 fee token maxAmountToken <code>uint256</code> The maximum amount of fee tokens that the users are willing to pay for the meta-tx deadline <code>uint256</code> Meta-transactions that are executed past the deadline will be reverted nonce <code>uint256</code> Replay protection data <code>bytes</code> The encoded function data that is to be executed hashedPayload <code>bytes32</code> EIP712-compliant hash struct"},{"location":"conveyor/conveyorv2/design/#executemetatx","title":"<code>executeMetaTx()</code>","text":"<pre><code>function executeMetaTx(MetaTransaction memory metatx, string memory domainName, uint256 tokenPricePerNativeToken, uint256 feeOffset, SIGNATURE_TYPE memory sig) public relayerOnly\n</code></pre> <p>This function executes the encoded function data, as defined in <code>MetaTransaction.data</code>. It calculates the amount of gas consumption within the enveloped function call and charges the user the fee amount that is based on the token/ETH price <code>tokenPricePerNativeToken</code>. This value is given by the Geode, calculated by an aggregation of token prices fetched from multiple sources. There are certain situations that could cause the transaction to revert, which the relayers will not be compensated for gas fee. The point of reverts are:</p> <ul> <li>Insufficient fee token balance</li> <li>Insufficient <code>maxAmountToken</code></li> <li>Invalid EIP 712 signature</li> <li>Out of gas error</li> </ul> Parameter Type metatx <code>MetaTransaction</code> The meta-transaction body domainName <code>string</code> The EIP712 domain name tokenPricePerNativeToken <code>uint256</code> ERC20 token price per ETH feeOffset <code>uint256</code> An additional amount of token to be taken into consideration when verifying the user's balance sig <code>SIGNATURE_TYPR</code> The user's EIP712 signature"},{"location":"conveyor/conveyorv2/design/#metastatus","title":"<code>MetaStatus</code>","text":"<pre><code>event MetaStatus(address sender, bool success, string error)\n</code></pre> <p>The <code>executeMetaTx</code> logs the event to indicate the status of the meta-tx. Execution failure within the meta-tx will not cause the function to revert. To view the error logs of a meta transaction, the client can simply listen for the <code>error</code> message emitted by this event.</p> Parameter Type sender <code>address</code> user address success <code>bool</code> status of the meta-tx error <code>string</code> reason of a reverted meta-tx"},{"location":"mev/examples/","title":"Attack Examples","text":""},{"location":"mev/examples/#front-running","title":"Front-Running","text":"<p>Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a\u00a0higher\u00a0gas price than an already pending transaction B so that A gets mined\u00a0before\u00a0B.</p>"},{"location":"mev/examples/#sandwich-attacks","title":"Sandwich Attacks","text":"<p>Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alice\u2019s transaction can create two of its own transactions which it inserts before and after Alice\u2019s transaction (sandwiching it). The adversary\u2019s first transaction buys Token A, which pushes up the price for Alice\u2019s transaction, and then the third transaction is the adversary\u2019s transaction to sell Token A (now at a higher price) at a profit.</p>"},{"location":"mev/examples/#back-running","title":"Back-Running","text":"<p>Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". </p> <p>Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched.1</p> <p>In order to maximise their changes of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts, in order to increase the chances that one of their transactions is ordered after the target but before any competitor.</p>"},{"location":"mev/examples/#liquidations","title":"Liquidations","text":"<p>Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered).</p> <ul> <li> <p>Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. </p> Strategy 1Strategy 2 <p>A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T.</p> <p>A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction TA to avoid the transaction fee bidding competition.</p> </li> <li> <p>The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price.</p> </li> </ul>"},{"location":"mev/examples/#time-bandit-attacks","title":"Time-Bandit Attacks","text":"<p>Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus.</p> <p>Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity.</p> <p>Now Dan has a choice: he can either mine on top of Sam\u2019s 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dan\u2019s at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block.</p>"},{"location":"mev/examples/#the-uncle-bandit-attack","title":"The Uncle Bandit Attack","text":"<p>Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up.</p> <p>Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it.</p> <p>How?</p> <p>In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too.</p> <p>A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. </p> <p>Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well. </p> <ol> <li> <p>https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1 \u21a9</p> </li> </ol>"},{"location":"mev/introduction/","title":"Introduction","text":"<p>Flashboys, Flashbots, Dark Forests and more..</p> <p></p> <p>This is a public resource for learning about Miner Extractable Value.</p> <p>We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue and also Automata Network's approach.</p> <p>Tip</p> <ol> <li>Find any errors? Click the  icon on each page to contribute.</li> <li>Want to share your feedback? Contact us here . </li> </ol>"},{"location":"mev/introduction/#what-is-miner-extractable-value","title":"What is Miner Extractable Value?","text":"<p>When one sends a transaction on the blockchain, there is a delay between the time when the transaction is broadcast to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions.</p> <p>Miner Extractable Value refers to the amount of profit that can be extracted from reordering and censoring transactions on the blockchain.</p>"},{"location":"mev/introduction/#why-does-this-matter1","title":"Why does this matter1?","text":""},{"location":"mev/introduction/#mev-can-harm-users","title":"MEV can harm users","text":"<p>MEV is an invisible tax that miners can collect from users.</p>"},{"location":"mev/introduction/#mev-can-destabilize-ethereum","title":"MEV can destabilize Ethereum","text":"<p>If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions.</p>"},{"location":"mev/introduction/#just-how-bad-is-the-problem","title":"Just how bad is the problem?","text":"<p>The Flashbots Dashboard  tracks Extracted MEV over time.</p> <p>It is estimated that &gt;$500M has been extracted since 1st January 2020.</p> <p>Dune Analytics  tracks Gas consumption by back-running bots. </p> <ol> <li> <p>According to https://research.paradigm.xyz/MEV \u21a9</p> </li> </ol>"},{"location":"mev/misc/","title":"Miscellaneous","text":""},{"location":"mev/misc/#what-happens-when-ethereum-moves-to-proof-of-stake","title":"What Happens when Ethereum moves to Proof-of-Stake?","text":"<p>The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value.</p> <p>This is an ongoing discussion and you can follow this here</p> <p>https://hackmd.io/@flashbots/ryuH4gn7d</p> <p>From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount.</p> <p>https://research.paradigm.xyz/staking</p>"},{"location":"mev/misc/#other-academic-papers","title":"Other Academic Papers","text":"<p>Tesseract</p> <p>Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment.</p> <p>https://eprint.iacr.org/2017/1153.pdf</p> <p>Calypso</p> <p>Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running.</p> <p>https://eprint.iacr.org/2018/209.pdf</p>"},{"location":"mev/resource-list/","title":"Resource List","text":"Name Type What Is Miner-Extractable Value (MEV)? Article Miners, Front-Running-as-a-Service Is Theft Article MEV and Me Article Ethereum is a Dark Forest Article Escaping the Dark Forest Article Ethereum Blockspace: Who Gets What and Why Article The fastest draw on the Blockchain: Ethereum Backrunning Article Security of Interoperability Presentation Gas Wars: Understanding Ethereum's Mempool &amp; Miner Extractable Value Podcast Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4) Video Enter the Dark Forest: the terrifying world of MEV and Flash bots Video Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability Video How To Get Front-Run on Ethereum mainnet Video Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges Research Paper Quantifying Blockchain Extractable Value: How dark is the forest? Research Paper High-Frequency Trading on Decentralized On-Chain Exchanges Research Paper Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain Research Paper"},{"location":"mev/terms-and-concepts/","title":"Terms and Concepts","text":""},{"location":"mev/terms-and-concepts/#defi","title":"DeFi","text":"<p>DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to &gt;$50B USD1.</p>"},{"location":"mev/terms-and-concepts/#automated-market-maker","title":"Automated Market Maker","text":"<p>A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset \\(x\\) and asset \\(y\\) in a pool have to abide by a constant \\(k\\). </p> <p>Examples of AMM Exchanges include Uniswap, Sushiswap, Balancer.</p>"},{"location":"mev/terms-and-concepts/#lending-platforms","title":"Lending Platforms","text":"<p>Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrower\u2019s debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesn\u2019t pay back the debt. </p> <p>Examples of lending platforms include Aave and Compound.</p>"},{"location":"mev/terms-and-concepts/#arbitrage","title":"Arbitrage","text":"<p>Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. </p>"},{"location":"mev/terms-and-concepts/#slippage","title":"Slippage","text":"<p>Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution \u2014 e.g., due to front-running transactions.</p>"},{"location":"mev/terms-and-concepts/#liquidations","title":"Liquidations","text":"<p>In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt.</p>"},{"location":"mev/terms-and-concepts/#priority-gas-auctions-pgas","title":"Priority gas auctions (PGAs)","text":"<p>As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users.</p>"},{"location":"mev/terms-and-concepts/#transaction-ordering","title":"Transaction Ordering","text":"<p>Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks.</p> <ol> <li> <p>https://defipulse.com/ \u21a9</p> </li> </ol>"},{"location":"mev/trick-the-bots/","title":"Attempts to Trick Bots","text":""},{"location":"mev/trick-the-bots/#salmonella","title":"Salmonella","text":"<p>Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. It\u2019s a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount.</p>"},{"location":"mev/trick-the-bots/#kattana","title":"Kattana","text":"<p>The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell.</p>"},{"location":"mev/trick-the-bots/#another-attempt-to-trick-bots","title":"Another attempt to trick bots","text":""},{"location":"mev/trick-the-bots/#background","title":"Background","text":"<p>Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay.</p> <p>Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included</p> <p>To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment.</p>"},{"location":"mev/trick-the-bots/#simulation-vs-reality","title":"Simulation vs Reality","text":"<p>Some really smart people found weaknesses among all of these defenses.</p> <p>The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production.</p>"},{"location":"mev/trick-the-bots/#the-second-defense-payment-only-on-a-sell-transaction","title":"The second defense - Payment only on a sell transaction","text":"<p>Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid!</p> <p>Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it!</p> <p>It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions here .</p>"},{"location":"mev/trick-the-bots/#from-victim-to-predator","title":"From Victim to Predator","text":"<p>One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so!</p>"},{"location":"mev/solutions/approaches/","title":"Different approaches to tackling the MEV problem","text":"<p>There are largely 2 schools of thought when it comes to approaching the MEV problem</p> <ol> <li>Offense - MEV is here to stay so let's find a way to extract and democratize it.</li> <li>Defense - MEV is bad so let's try to prevent it.</li> </ol> <p>As such we have put approaches into 2 categories</p> <ol> <li>Front-running as a Service (FaaS) or MEV Auctions (MEVA)</li> <li>MEV Minimization/Prevention</li> </ol> <p>At Automata Network we are in the Defense camp. Our solution Conveyor ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.</p>"},{"location":"mev/solutions/faas-or-meva/","title":"Front-running as a Service (FaaS) or MEV Auctions (MEVA)","text":"<p>In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users.</p> <p>Vitalik Buterin - </p> <p>Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors. </p> <p>Phil Daian, co-author of Flash Boys 2.0 - </p> <p>In this article, I\u2019m going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isn\u2019t like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community. </p>"},{"location":"mev/solutions/faas-or-meva/#private-transactions","title":"Private Transactions","text":"<p>Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions).</p> <p>Examples include 1inch Exchange's Stealth Transactions, Taichi Network and BloXroute.</p> <p></p> <p><p>Private Transactions offered by Taichi Network</p></p> <p>bloXroute Labs has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec).</p> <p>Note</p> <p>For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad1:</p> <ol> <li>Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8-&gt;0.15 sec matters.</li> <li>When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees.</li> </ol> <p>Links</p> <ul> <li>https://docs.bloxroute.com/apis/frontrunning-protection</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#backrunme-by-bloxroute","title":"BackRunMe by bloXroute","text":"<p>BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. </p> <p>The profit sharing ratio is as follows: 50% to miners, 25% to users, 20% to searchers and 5% to bloXroute.</p> <p>Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. </p> <p>Links</p> <ul> <li>https://backrunme.com/#/swap</li> <li>https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#flashbots","title":"Flashbots","text":"<p>Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference.</p> <p>ELI5</p> <p> https://twitter.com/_silto_/status/1381292907567722498</p> <p>Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included.</p> <p>The transactions that the bots want to include are sent through the MEV-Relay as bundles containing:</p> <ul> <li>the transactions to execute</li> <li>a tip to the miner, coming as an ETH transfer</li> </ul> <p>These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip.</p> <p>Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users.</p> <p>Links</p> <ul> <li>GitHub: https://github.com/flashbots</li> <li>Research: https://github.com/flashbots/mev-research</li> <li>Monthly Meetings: https://github.com/flashbots/pm</li> <li>API: https://blocks.flashbots.net/</li> <li>Discord: https://discord.gg/7hvTycdNcK</li> <li>Medium: https://medium.com/flashbots</li> <li>https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752</li> <li>https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02</li> <li>https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#mistx-by-alchemist","title":"mistX by alchemist","text":"<p>mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet.</p> <p>The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched.</p> <p>Links</p> <ul> <li>https://app.mistx.io/#/exchange</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#keeperdao","title":"KeeperDAO","text":"<p>KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols.</p>"},{"location":"mev/solutions/faas-or-meva/#the-hiding-game","title":"The Hiding Game","text":"<p>One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to \u201chide\u201d MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself.</p>"},{"location":"mev/solutions/faas-or-meva/#heres-the-eli5","title":"Here's the ELI5","text":"<p>Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities.</p>"},{"location":"mev/solutions/faas-or-meva/#kcompound-phase-2-of-the-hiding-game","title":"kCompound (Phase 2 of the Hiding Game)","text":"<p>kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation.</p> <p>Links</p> <ul> <li>https://keeperdao.com/#/</li> <li>Wiki: https://github.com/keeperdao/docs/wiki</li> <li>kCompound: https://medium.com/keeperdao/introducing-kcompound-a23511c847a0</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#archerswap","title":"ArcherSwap","text":"<p>Archerswap is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. </p> <p>One is for searchers to submit Flashbots-compatible bundles.  The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. </p> <p>Links</p> <ul> <li>https://swap.archerdao.io/#/swap</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#optimism","title":"Optimism","text":"<p>Optimism are the original proposers of MEVA.</p> <p>MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks.</p> <p></p>"},{"location":"mev/solutions/faas-or-meva/#implementing-the-auction","title":"Implementing the Auction","text":"<p>The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined.\u00a0Block producers determine transaction inclusion, and\u00a0Sequencers\u00a0determine transaction ordering.</p>"},{"location":"mev/solutions/faas-or-meva/#block-producers-transaction-inclusion","title":"Block producers - Transaction Inclusion","text":"<p>Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks.</p>"},{"location":"mev/solutions/faas-or-meva/#sequencers-transaction-ordering","title":"Sequencers - Transaction Ordering","text":"<p>Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected.</p>"},{"location":"mev/solutions/faas-or-meva/#implementation-on-layer-2","title":"Implementation on Layer 2","text":"<p>It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time.</p> <p>Links</p> <ul> <li>https://optimism.io/</li> <li>https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788</li> <li>https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#miningdao","title":"MiningDAO","text":"<p>MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. </p> <p>One is for searchers to submit Flashbots-compatible bundles.  The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. </p> <p>Links</p> <ul> <li>https://miningdao.io</li> <li>https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad</li> </ul>"},{"location":"mev/solutions/faas-or-meva/#backbone-cabal","title":"BackBone Cabal","text":"<p>BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%).</p> <p>YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching).</p> <p>Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes.</p> <p>Links</p> <ul> <li>https://backbonecabal.com/</li> <li>Knowledge Base: https://backbone-kb.netlify.app/</li> <li>SushiSwap Proposal: https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159</li> </ul> <ol> <li> <p>https://twitter.com/bloXrouteLabs/status/1357026919905173509\u00a0\u21a9</p> </li> </ol>"},{"location":"mev/solutions/mev-minimization-prevention/","title":"MEV Minimization/Prevention","text":""},{"location":"mev/solutions/mev-minimization-prevention/#conveyor-the-automata-network-approach-to-tackling-mev","title":"Conveyor - The Automata Network approach to tackling MEV","text":"<p>At Automata, we have created Conveyor, a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering.</p> <p></p> <p>When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following:</p> <ol> <li>Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch.</li> <li>Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time.</li> </ol> <p>From the DEX\u2019s perspective, they can choose to accept either</p> <ol> <li>Ordered transactions from Automata\u2019s Conveyor which is free from transaction reordering and other front-running transactions</li> <li>Other unordered transactions (which include front-running etc) that may negatively impact their users</li> </ol>"},{"location":"mev/solutions/mev-minimization-prevention/#why-should-users-trust-conveyor","title":"Why should users trust Conveyor?","text":"<p>Automata\u2019s Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that:</p> <ul> <li>The Geode code is untampered with</li> <li>The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions)</li> </ul> <p>Importantly, Automata\u2019s Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms \u2014 zero modifications needed. Here\u2019s a demo on how trading pairs on Uniswap can be protected.</p>"},{"location":"mev/solutions/mev-minimization-prevention/#an-industry-first-oblivious-ram","title":"An industry-first: Oblivious RAM","text":"<p>In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing.</p> <p>This is where the Oblivious RAM algorithm comes into play. Automata\u2019s implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps.</p> <p>This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks.</p> <ul> <li>Robust P2P Primitives Using SGX Enclaves RAID 2020</li> <li>PRO-ORAM: Practical Read-Only Oblivious RAM RAID 2019</li> <li>OblivP2P: An Oblivious Peer-to-Peer Content Sharing System USENIX Security 2016</li> <li>Preventing Page Faults from Telling Your Secrets Asia CCS 2016</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#the-fair-sequencing-service-by-chainlink","title":"The Fair Sequencing Service by ChainLink","text":"<p>The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it.</p> <p>FSS is a framework for implementing ordering policies, of which Aequitas (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.)</p> <p>Links</p> <ul> <li>Blog post: https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/</li> <li>Whitepaper (to be released later)</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#arbitrum-by-offchain-labs","title":"Arbitrum by Offchain Labs","text":"<p>Arbitrum is against MEVA and FaaS.</p> <p>3 Modes of Arbitrum:</p> <ol> <li> <p>Single Sequencer: L2 MEV-Potential (Mainnet Beta)</p> <p>For Arbitrum\u2019s initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them.</p> </li> <li> <p>Distributed Sequencer With Fair Ordering: L2-MEV-minimized (Mainnet Final Form)</p> <p>The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via the first BFT algorithm that enforces fair ordering within consensus (Aequitas). Here, L2 MEV is only possible if &gt;1/3 of the sequencing-parties maliciously collude, hence \u201cMEV-minimized.\u201d</p> </li> <li> <p>No Sequencer: No L2 MEV</p> <p>A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture.</p> </li> </ol> <p>Links</p> <ul> <li>https://offchainlabs.com/</li> <li>https://medium.com/offchainlabs/front-running-as-a-service-334c929c945</li> <li>https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#vega-protocol","title":"Vega Protocol","text":"<p>Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validator\u2019s discretion.</p> <p>\"If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b\u201d.\u00a0This is a property that can be assured of at any time with a minimal impact on performance.</p> <p>To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market.</p> <p>Links</p> <ul> <li>https://vega.xyz/</li> <li>https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb</li> <li>Wendy, the Good Little Fairness Widget: https://vega.xyz/papers/fairness.pdf</li> <li>Video: https://www.youtube.com/watch?v=KjfLj5fhkGQ&amp;t=18s&amp;ab_channel=VegaProtocol</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#cowswap","title":"CowSwap","text":"<p>A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional \u201csolvers\u201d which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user.</p> <p>Links</p> <ul> <li>https://cowswap.exchange/#/swap</li> <li>https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#veedo-by-starkware","title":"Veedo by StarkWare","text":"<p>VeeDo is StarkWare\u2019s STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public.</p> <p>2 approaches using privacy to minimize MEV</p> <ol> <li>Time-locks as part of the protocol layer</li> <li>Time-locks on Ethereum with smart contracts - supported today</li> </ol> <p>Links</p> <ul> <li>https://starkware.co/</li> <li>https://medium.com/starkware/presenting-veedo-e4bbff77c7ae</li> <li>https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#libsubmarine","title":"LibSubmarine","text":"<p>LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain.</p> <p>Links</p> <ul> <li>https://libsubmarine.org/</li> <li>Video: https://www.youtube.com/watch?v=N8PDKoptmPs&amp;feature=emb_imp_woyt&amp;ab_channel=IC3InitiativeforCryptocurrenciesandContracts</li> <li>GitHub: https://github.com/lorenzb/libsubmarine</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#sikka","title":"Sikka","text":"<p>Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators.</p> <p>Links</p> <ul> <li>https://sikka.tech/</li> <li>https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p</li> </ul>"},{"location":"mev/solutions/mev-minimization-prevention/#shutter-network","title":"Shutter Network","text":"<p>Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol.</p> <p>A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed.</p> <p>A Shutter transaction flow:</p> <ol> <li>Created and encrypted in the user's wallet;</li> <li>Sent to the batcher contract as a standard Ethereum transaction;</li> <li>Picked up and decrypted by the keypers;</li> <li>Sent to the executor contract, and</li> <li>Forwarded to the target contract.</li> </ol> <p>Links</p> <ul> <li>https://shutter.ghost.io/</li> <li>GitHub: https://github.com/brainbot-com/shutter </li> </ul>"},{"location":"mev/solutions/others/","title":"Others","text":""},{"location":"mev/solutions/others/#bprotocol","title":"B.Protocol","text":"<p>BProtocol aims to shift MEV to users.</p> <p>Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating.</p> <p>Links</p> <ul> <li>https://www.bprotocol.org/</li> <li>https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit</li> </ul>"},{"location":"nftfair/introduction/","title":"Introduction","text":""},{"location":"nftfair/introduction/#overview","title":"Overview","text":"<p>It comes as a surprise that NFT launches are hardly fair and hurt the very community built around it. Users have reasonable expectations of obtaining an item from an NFT collection, but instead find that pre-sniping and metadata exploits - where traits are revealed on-chain before the sale - are so common as to be expected. </p> <p>It was in light of these current shortcomings that we sat down and deliberated on what a viable solution could be, and how it would look like. It was clear to us that fairness would be a crucial part of such a design. With the support of Conveyor, NFTFair was launched. </p>"},{"location":"nftfair/introduction/#features","title":"Features","text":"<ul> <li>Unexploitable fairness  Powered by Conveyor to ensure that metadata is not revealed before the NFT is bought and settled</li> <li>True randomness  Random numbers directly generated from Silicon, with the option of utilizing Verifiable Random Function </li> <li>Multi-chain support  EVM/WASM compatible, with support for major ecosystem blockchains such as Ethereum, BSC, and Polygon</li> <li>Gasless transactions  Intuitive experience to eliminate user friction and complexity </li> </ul>"},{"location":"nftfair/introduction/#fifo-fairdrops","title":"(FIFO) Fairdrops","text":"<p>Attackers with a technical edge can skip ahead of the queue and interact directly with the smart contract of a new collection. The rarest NFTs are snapped up before the average user has a chance to connect their wallet once the sale goes public. For an effective launch process, metadata cannot be revealed at any point of the NFT journey from bidding, selection to distribution. </p> <p>With NFTFair, first-in-first-out ordering enforced by Conveyor removes any room for exploitation. </p>"},{"location":"nftfair/introduction/#mystery-boxes","title":"Mystery Boxes","text":"<p>Users anticipate the excitement of not knowing the exact item and rarity of an item when they participate in a mystery box collection. The surprise, however, can turn sour, when distribution is not truly randomized. The assumption that each user has an equal opportunity to mint an NFT with random metadata is just that.</p> <p>AT NFTFair, no one, including the hosting nodes, is able to glean the ordering before it has been decided. It is out of the question for anyone to favor bids based on undisclosed information, which ensures randomization.</p>"},{"location":"nftfair/introduction/#templates","title":"Templates","text":"<p>NFTFair currently supports:</p> <ul> <li>FIFO (First-In-First-Out) Fairdrops</li> <li>Mystery Boxes Fairdrops </li> </ul> <p>More curated template versions coming soon. </p>"},{"location":"nftfair/introduction/#network","title":"Network:","text":"<p>NFTFair is compatible with most EVM networks, and is live on: </p> <ul> <li>BSC</li> <li>Polygon </li> </ul> <p>We are also working hard to expand the list of supported networks. Share your project with us here or drop us a message.</p>"},{"location":"nftfair/introduction/#category","title":"Category","text":"<p>A category is what defines a collection of NFTs. Properties that can be configured include: </p> <ul> <li>NFT Contract</li> <li>Range of Token IDs</li> <li>Sales Price</li> <li>Maximum Purchase/Claim Limit</li> </ul> <p>Projects must define at least one category before sending NFTs to Fairdrop vaults.</p>"},{"location":"nftfair/introduction/#sales","title":"Sales","text":"<p>Prices can be set for NFTs in different categories (i.e. collections). Proceeds from the sale can be withdrawn from the platform once the launch has ended. </p> <p>As each Fairdrop vault only accepts a single ERC20 payment token, it is not possible to price Category A at 100 USDC, and Category B at 100 BTC. Projects can choose to price different categories for varying amounts of the same token. For example, Category A at 100 UDSC and Category B at 1000 USDC. </p>"},{"location":"nftfair/introduction/#costs","title":"Costs","text":"<p>NFT launches on the platform are performed with gasless transactions. For users to benefit from zero-cost transactions, projects may choose to opt for relayer-sponsored transactions. Projects bear the full gas cost and users do not have to pay for any transaction fees. </p> <p>Please reach out to us for more cost details. </p>"},{"location":"nftfair/introduction/#to-get-started","title":"To get started","text":"<p>Make sure you have the below information ready: </p> <ul> <li> <p>Activity name. Example: Automata NFT Egg Hunt</p> </li> <li> <p>Page title. Example: Come and crack your own egg! </p> </li> <li> <p>Start and end time for the Fairdrop</p> </li> <li> <p>Official website and social media links </p> </li> <li> <p>Short description to introduce your project. (Example: Automata NFT Egg Hunt is a mystery box competition launched and hosted on NFTFair to celebrate the spirit of Easter with the community.)</p> </li> <li> <p>List of commmon FAQs </p> </li> <li> <p>A horizontal brand logo, more than 200px. Example</p> </li> <li> <p>A square brand logo, more than 500px. Example</p> </li> <li> <p>A banner related to the theme of the Fairdrop, 2132 x 224px. Example</p> </li> <li> <p>A favicon for the browser tab, 32 x 32px. Example</p> </li> </ul> <p>Once the setup is complete, projects can then transfer or mint the NFTs to the Fairdrop Vaults. If you wish to enable the wallet connect function with your infura id, please share the id with us. Read more about Wallet Connect and Infura ID.</p>"},{"location":"nftfair/contracts/factory/","title":"NFTFairFactory","text":"<p>The Factory contract stores template bytecodes. Upon deployment of the vaults, the owner can select a template by providing its corresponding ID. Once the vault has been deployed, they get full ownership of the Vault contract, implemented using OpenZeppelin's <code>Ownable</code> library.</p> <p>The admin of the Factory contract has the ability to modify the bytecodes stored in the factory, as a means of upgrading existing templates or adding a new template to the platform. Any changes on the Factory contract will NOT impact any existing vaults. Owners who opted to use a newer version of the vault template, must re-deploy a vault.</p> <p>This Factory contract is upgradeable using a Transparent Proxy.</p>"},{"location":"nftfair/contracts/factory/#initialize","title":"<code>initialize()</code>","text":"<p><pre><code>function initialize(address _owner)\n</code></pre> Initializes the state of the contract. In this case, this method initializes the owner of the Factory contract. This method must be implemented for a proxied contract. For more information, see <code>Initializable</code> on OpenZeppelin.</p> <p> Note: It is advisable to encode this method and pass as a <code>data</code> argument upon invoking the <code>upgradeTo()</code> method on the proxy contract for the first time. This is to avoid leaving the proxy uninitialized post-deployment.</p>"},{"location":"nftfair/contracts/factory/#addvaulttemplate","title":"<code>addVaultTemplate()</code>","text":"<p><pre><code>function addVaultTemplate(bytes memory _bytecode)\n</code></pre> Adds a new bytecode template to the Factory, and returns the ID of the template. Requires <code>onlyOwner()</code></p> Parameter Type Description Bytecode <code>bytes</code> The creation bytecode of the template"},{"location":"nftfair/contracts/factory/#updatevaulttemplate","title":"<code>updateVaultTemplate()</code>","text":"<pre><code>function updateVaultTemplate(uint256 _templateId, bytes memory _bytecode)\n</code></pre> <p>Updates an existing vault template. Requires <code>onlyOwner()</code>.</p> <p> Note: This does not affect existing vaults. Given the immutable nature of smart contracts, the template of the vault permanently adheres to the version of the bytecode based on the time of deployment.</p> Parameter Type Description Template ID <code>uint256</code> The ID of a template. Reverts if an invalid ID is provided Bytecode <code>bytes</code> The creation bytecode of the template"},{"location":"nftfair/contracts/factory/#createvault","title":"<code>createVault()</code>","text":"<pre><code>function createVault(uint256 _templateId, bytes calldata _constructorData)\n</code></pre> <p>Deploys a vault according to a template provided by its ID.</p> Parameter Type Description Template ID <code>uint256</code> The ID of a template. Reverts if an invalid ID is provided Constructor Data <code>bytes</code> ABI encoded constructor data"},{"location":"nftfair/contracts/factory/#getvaulttemplate","title":"<code>getVaultTemplate()</code>","text":"<pre><code>function getVaultTemplate(uint256 _templateId) external view returns (bytes memory)\n</code></pre> <p>Gets the bytecode of a given template ID.</p>"},{"location":"nftfair/contracts/factory/#getvaulttemplatecount","title":"<code>getVaultTemplateCount()</code>","text":"<pre><code>function getVaultTemplateCount() external view returns (uint256)\n</code></pre> <p>Returns the number of templates stored in the Factory.</p>"},{"location":"nftfair/contracts/summary/","title":"Summary","text":"<p>This documentation outlines the contract specification of the platform. The contracts consist of three components:</p> <ul> <li><code>NFTFairFactory</code> - The factory contract to deploy vaults based on a given template. Proxied by <code>NFTFairProxy</code> for upgradability.</li> <li><code>NFTFairTreasury</code> - The central contract that collects sales revenues generated from vaults, and other protocol-related payment.</li> <li><code>NFTFairVaultBase</code> - The base Vault contract that implements essential features of a vault, can be extended with additional implementations that are tailored to a specific template.</li> </ul> <p>Currently, the platform supports the two templates:</p> <ul> <li>FIFO</li> <li>Mystery Boxes</li> </ul> <p>We plan to add more templates in the future.</p>"},{"location":"nftfair/contracts/summary/#addresses","title":"Addresses","text":""},{"location":"nftfair/contracts/summary/#bsc","title":"BSC","text":"Contract Address <code>NFTFairFactory</code> 0x67F7e0C322a067C70e1eE99873Fe4163f4A02edD <code>NFTFairProxy</code> 0x062154774E1726246c75A4e8f05EDC675d8B39a1 <code>NFTFairTreasury</code> 0x39c805A56EeF49BcD7C6c14d5dcf6e7f0daf63A4"},{"location":"nftfair/contracts/treasury/","title":"NFTFairTreasury","text":"<p>The treasury contract serves as a central entity for collecting payment and sales revenue generated from vaults. This design is intended such that users would send at most one <code>approve()</code> call for one ERC20 token that can be spent across all vaults on the NFTFair platform.</p> <p>To ensure the protocol does not drain the user's allowance without explicit approval, the <code>collectPayment()</code> method requires an EIP712 Signature, indicating the amount of specified tokens to be spent by an authorized address.</p> <p>The structure of the EIP712 Message (similarly based on EIP 2612) is the following:</p> <pre><code>Permit: [\n{ name: 'owner', type: 'address' },\n{ name: 'spender', type: 'address' },\n{ name: 'token', type: 'address' },\n{ name: 'value', type: 'uint256' },\n{ name: 'nonce', type: 'uint256' },\n{ name: 'deadline', type: 'uint256' },\n],\n</code></pre> Parameter Description owner The owner of the token. This is most likely the user's address spender The authorized spender. This is most likely the vault's address token The address of the ERC20 token to be spent value The payment amount nonce The user's transaction count in the Treasury contract deadline Transaction reverts at <code>block.timestamp &gt; deadline</code> <p>In the future, the protocol may set a fee upon payment collection, using basis points. This value is given a ceiling of 3000. In other words. the protocol can not set a fee higher than 30%.</p> <p>Last but not least, the protocol has the ability to exempt fees or configure a custom fee percentage for a specified spender. If an address is neither exempt nor assigned with a custom basis point, the Treasury will collect fee using the default BP.</p>"},{"location":"nftfair/contracts/treasury/#collectpayment","title":"<code>collectPayment()</code>","text":"<pre><code>function collectPayment(\naddress _buyer,\naddress _token,\nuint256 _amount,\nuint256 _deadline,\nbytes calldata _signature\n)\n</code></pre> <p>This function is called by the payee directly, to collect payment from the buyer.</p> Parameter Type Description buyer <code>address</code> The owner of the token. This is most likely the user's address token <code>address</code> The address of the ERC20 token to be spent amount <code>uint256</code> The payment amount deadline <code>uint256</code> Transaction reverts at <code>block.timestamp &gt; deadline</code> signature <code>bytes</code> The user signed EIP712 message"},{"location":"nftfair/contracts/treasury/#setnewbp","title":"<code>setNewBp</code>","text":"<p><pre><code>function setNewBp(uint256 _newBp)\n</code></pre> Sets a new default BP. Requires <code>onlyOwner()</code></p> Parameter Type Description New BP <code>uint256</code> REVERTS &gt; 3000"},{"location":"nftfair/contracts/treasury/#setaddressbp","title":"<code>setAddressBp</code>","text":"<p><pre><code>function setAddressBp(address _spender, uint256 _newBp)\n</code></pre> Specifies a custom BP for <code>_spender</code>. Requires <code>onlyOwner()</code></p> Parameter Type Description Spender <code>address</code> This is most likely the vault's address. New BP <code>uint256</code> REVERTS &gt; 3000"},{"location":"nftfair/contracts/treasury/#toggleaddressexemption","title":"<code>toggleAddressExemption</code>","text":"<p><pre><code>function toggleAddressExemption(address _spender)\n</code></pre> Exempts/Unexempts <code>_spender</code> from paying fees. Requires <code>onlyOwner()</code></p> Parameter Type Description Spender <code>address</code> This is most likely the vault's address."},{"location":"nftfair/contracts/treasury/#recovererc20","title":"<code>recoverERC20()</code>","text":"<pre><code>function recoverERC20(\naddress _recipient,\naddress _token,\nuint256 _amount\n)\n</code></pre> <p>Withdraws the protocol revenue. Requires <code>onlyOwner()</code>.</p> Parameter Type Description recipient <code>address</code> The recipient address token <code>address</code> The address of the ERC20 token amount <code>uint256</code> The amount to withdraw"},{"location":"nftfair/contracts/treasury/#getfeemultiplier","title":"<code>getFeeMultiplier()</code>","text":"<pre><code>function getFeeMultiplier(address _spender) public view returns (uint256 multiplier)\n</code></pre> <p>Returns the BP value for a specified <code>_spender</code>.</p>"},{"location":"nftfair/contracts/vault/base/","title":"NFTFairVaultBase","text":"<p>NFTFair Vaults are responsible for fairly distributing NFTs, a.k.a. Fairdrop, this is all made possible by Conveyor. The Vault contract achieves this by inheriting the <code>ConveyorBase</code> contract.</p> <p>The <code>NFTVaultBase</code> contract provides the essential features to receive and organize NFTs by assigning categories. A category must be created prior to receiving any NFTs. The vault may reject any incoming NFTs, if a category is not created for that particular NFT contract.</p> <p>The structure of the Category is the following: <pre><code>struct CategoryInfo {\naddress nft;\nEnumerableSet.UintSet ids;\nEnumerableSet.UintSet claimable_ids;\nuint256 purchaseLimit;\nuint256 price;\n}\n</code></pre></p> Parameter Description NFT The address of the NFT contract. This address cannot be modified after initialization ids A list of token IDs that the vault has received. IDs are appended when the <code>onERC721Received</code> hook is called claimable ids A list of token IDs that are available to claim. A subset of the <code>ids</code> list. Purchase Limit The maximum amount of NFTs that a user is eligible to claim from the category Price Amount to be paid in <code>paymentToken</code> to purchase an NFT"},{"location":"nftfair/contracts/vault/base/#createcategory","title":"<code>createCategory()</code>","text":"<pre><code>function createCategory(\naddress _nft,\nuint256 _max,\nuint256 _price\n)\n</code></pre> <p>Initializes a category.</p> Parameter Type Description NFT <code>address</code> The NFT contract address. CANNOT BE CHANGED AFTER INITIALIZATION Max <code>uint256</code> The maximum amount of NFTs that a user is eligible to claim from the category Price <code>uint256</code> Amount to be paid in <code>paymentToken</code> to purchase an NFT"},{"location":"nftfair/contracts/vault/base/#updatecategory","title":"<code>updateCategory</code>","text":"<pre><code>function updateCategory(\nuint256 _category,\nuint256 _maxPurchase,\nuint256 _price\n)\n</code></pre> <p>Updates the properties of a specified category, except for the NFT address. A new category must be created separately for a different NFT contract.</p> Parameter Type Description Category <code>uint256</code> The integer representation of a category Max <code>uint256</code> The maximum amount of NFTs that a user is eligible to claim from the category Price <code>uint256</code> Amount to be paid in <code>paymentToken</code> to purchase an NFT"},{"location":"nftfair/contracts/vault/base/#configurepayment","title":"<code>configurePayment</code>","text":"<pre><code>function configurePayment(address _newToken, uint256[] memory _prices)\n</code></pre> <p>This function allows changing the payment token and/or updates prices across all categories in a single function call. </p> Parameter Type Description Token <code>address</code> The ERC20 token address Prices <code>uint256[]</code> The length of the array must either be 0 or the total number of categories. This transaction reverts otherwise."},{"location":"nftfair/contracts/vault/base/#revenuepayout","title":"<code>revenuePayout</code>","text":"<pre><code>function revenuePayout(address _beneficiary, address _token)\n</code></pre> <p>The Vault owner calls this function to withdraw revenue out of the vault.</p> Parameter Type Description Beneficiary <code>address</code> The recipient address Token <code>address</code> The ERC20 token address"},{"location":"nftfair/contracts/vault/base/#recover","title":"<code>recover</code>","text":"<p><pre><code>function recover(uint256[] memory _categoryArr, address _recipient)\n</code></pre> The owner can invoke this method to withdraw remaining NFTs from one or more specified categories. This function call effectively empties all categories that are being recovered. </p> Parameter Type Description Categories <code>uint256[]</code> One or more categories Recipient <code>address</code> The recipient address"},{"location":"nftfair/contracts/vault/base/#claimed","title":"<code>claimed</code>","text":"<pre><code>function claimed(address _user, uint256 _category) public view override returns (uint256[] memory)\n</code></pre> <p>Returns a list of token IDs that has been claimed by the <code>_user</code> from a specified <code>_category</code></p>"},{"location":"nftfair/contracts/vault/base/#getclaimableids","title":"<code>getClaimableIds</code>","text":"<pre><code>function getClaimableIds(uint256 _category) public view override returns (uint256[] memory)\n</code></pre> <p>Returns a list of available token IDs from a specified <code>_category</code>.</p>"},{"location":"nftfair/contracts/vault/base/#getcategoryprice","title":"<code>getCategoryPrice</code>","text":"<p><pre><code>function getCategoryPrice(uint256 _category) external view override returns (uint256)\n</code></pre> Returns the amount of <code>paymentToken</code> required to purchase a single NFT from the specified <code>_category</code>. Call the <code>paymentToken()</code> method to get the ERC20 address of the payment token.</p>"},{"location":"nftfair/contracts/vault/base/#getcategorynft","title":"<code>getCategoryNft</code>","text":"<p><pre><code>function getCategoryNft(uint256 _category) external view override returns (address)\n</code></pre> Returns the address of the NFT contract from the specified <code>_category</code>.</p>"},{"location":"nftfair/contracts/vault/base/#getcategorynftids","title":"<code>getCategoryNftIds</code>","text":"<p><pre><code>function getCategoryNftIds(uint256 _category) external view returns (uint256[] memory)\n</code></pre> Returns the list of token IDs that has been added into this category. This list excludes token IDs that had been recovered by the owner.</p>"},{"location":"nftfair/contracts/vault/base/#claimablecount","title":"<code>claimableCount</code>","text":"<pre><code>function claimableCount(uint256 _category) external view returns (uint256)\n</code></pre> <p>Return the number of available token IDs from a specified <code>_category</code>.</p> <p>This base contract can be extended to implement the <code>claim()</code> function. <code>claim()</code> functions are implemented differently by their templates.</p>"},{"location":"nftfair/contracts/vault/templates/fifo/","title":"FIFO Vault","text":"<p>First-in-first-out vaults correctly enforce the order of incoming claim transactions.</p> <pre><code>function claim(\nuint256 _category,\nuint256 _id,\nuint256 _deadline,\nbytes calldata _sig\n)\n</code></pre> Parameter Type Description Category <code>uint256</code> The integer representation of a category ID <code>uint256</code> NFT Token ID to claim Deadline <code>uint256</code> Transaction reverts at <code>block.timestamp &gt; deadline</code> Sig <code>bytes</code> The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass <code>0x</code> if <code>paymentToken == address(0)</code>"},{"location":"nftfair/contracts/vault/templates/mysteryboxes/","title":"Mystery Boxes Vault","text":"<p>Mystery box style vaults are more restricted than FIFO vaults, in a way that the token ID is randomly chosen and not revealed until the transaction has been broadcasted.</p> <pre><code>function claim(\nuint256 _category,\nuint256 _deadline,\nbytes calldata _sig\n)\n</code></pre> Parameter Type Description Category <code>uint256</code> The integer representation of a category Deadline <code>uint256</code> Transaction reverts at <code>block.timestamp &gt; deadline</code> Sig <code>bytes</code> The user's EIP712 message to authorize the Treasury for collecting the payment. You may pass <code>0x</code> if <code>paymentToken == address(0)</code>"},{"location":"nftfair/users/activities/","title":"Overview","text":""},{"location":"nftfair/users/activities/#homepage","title":"Homepage","text":"<p>The homepage is the main site where users can find a list of past, current and future Fairdrop events. Each activity contains information such as:  - The launch network - The event duration - The template format - The total number of NFTs</p> <p>Users can click on the \"Visit Activity Page\" button to be redirected to the activity site. </p>"},{"location":"nftfair/users/activities/#activity-sites","title":"Activity Sites","text":"<p>The activity site is where users participate in the Fairdrop event. To claim/purchase NFTs, users need to:</p> <ul> <li>Be eligible for the Fairdrop based on the launch requirements </li> <li>Have a sufficient token balance for the asset they're transacting in, i.e. ERC20/BEP20 tokens. Users no longer need to hold platform native tokens such as ETH or BNB due to the nature of gasless transactions</li> <li>Make sure their total claim/purchase does not exceed the maximum limit</li> <li>Purchase NFT(s) within the duration of the event</li> </ul>"},{"location":"nftfair/users/activities/#approval","title":"Approval","text":"<p>Users may be prompted to submit an <code>approve()</code> transaction for an ERC20 token that do not have prior history with the protocol. In other words, an <code>approve()</code> transaction prompt is always required to authorize new ERC20 tokens to be used for payment to be collected by the Treasury contract.</p> <p>Once all of the above conditions have met, users may select one (or more) category that they wish to claim an NFT from. Users are then prompted to sign two EIP712 messages for authentication.</p> <ul> <li>The first message gives permission to the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price.</li> <li>The second message gives permission to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge.</li> </ul>"},{"location":"nftfair/users/activities/#watch","title":"Watch","text":"<p>Check out this video to see NFTFair in action.</p>"},{"location":"nftfair/users/faq/","title":"Frequently Asked Questions","text":""},{"location":"nftfair/users/faq/#general","title":"General","text":""},{"location":"nftfair/users/faq/#1-what-is-nftfair-how-is-this-platform-different-from-other-nft-platforms-eg-opensea","title":"1. What is NFTFair? How is this platform different from other NFT platforms? (e.g. OpenSea)","text":"<p>NFTFair is a platform powered by Conveyor to ensure NFTs are being distributed (or sold) fairly. The average user is able to avoid being front-run by snipers, technically sophisticated buyers, or trading bots. Conveyor achieves this by enforcing the fair ordering of transactions. </p> <p>Click here to try it out yourself. </p>"},{"location":"nftfair/users/faq/#2-what-is-a-fairdrop","title":"2. What is a Fairdrop?","text":"<p>A Fairdrop is a single NFT distribution event being held for a certain duration. A vault contract is deployed and to be used only for a single Fairdrop event, which stores a fixed number of NFTs that is ready to be claimed by Fairdrop participants.</p> <p>A user-facing activity site is also created for a Fairdrop event, for participants to easily interact with the vault contract to claim NFTs.</p>"},{"location":"nftfair/users/faq/#partners","title":"Partners","text":""},{"location":"nftfair/users/faq/#1-can-i-start-a-fairdrop-activity-to-sell-or-give-away-nfts-from-an-existing-contract","title":"1. Can I start a Fairdrop activity to sell or give away NFTs from an existing contract?","text":"<p>Yes. Simply transfer the NFTs to a vault contract on NFTFair to begin setting up the activity. The platform offers support for contracts that follow the ERC721 and ERC1155 standard. </p> <p>Drop us a message at nftfair@ata.network to get started with your own Fairdrop. </p>"},{"location":"nftfair/users/faq/#participants","title":"Participants","text":""},{"location":"nftfair/users/faq/#1-why-am-i-not-qualified-to-claim-nfts","title":"1. Why am I not qualified to claim NFTs?","text":"<p>Certain Fairdrops may be be open only to participants on a whitelist. If you are not eligible, please reach out to the project directly, as we do not have control over whitelists.</p>"},{"location":"nftfair/users/faq/#2-how-much-does-it-cost-to-claim-nfts","title":"2. How much does it cost to claim NFTs?","text":"<p>The price varies by the Fairdrop and its category. You can find NFT pricing on the activity site.</p>"},{"location":"nftfair/users/faq/#3-how-many-nfts-can-i-claim","title":"3. How many NFTs can I claim?","text":"<p>This also varies by the Fairdrop and its category. More details can be found on the activity site.</p>"},{"location":"nftfair/users/faq/#4-why-am-i-prompted-to-send-an-approve-transaction-what-am-i-approving","title":"4. Why am I prompted to send an <code>approve()</code> transaction? What am I approving?","text":"<p>If this is your first time using Conveyor, you will likely be prompted with (at most) two <code>approve()</code> transactions.</p> <p>The first <code>approve()</code> transaction grants permission for the collection of gas payment ERC20 tokens. There are certain scenarios which may omit this requirement, such as:</p> <ul> <li>Fairdrops that opt for relayer-sponsored transactions. In this case, users do not have to bear the cost of transaction fees.</li> <li>The user's token of choice has previously been approved for other Conveyor projects.</li> </ul> <p>The second <code>approve()</code> transaction grants permission to the Treasury contract for collecting payment from NFT sales. This permission is valid for all vaults and other contracts on the platform that are receiving payments via the Treasury contract.</p>"},{"location":"nftfair/users/faq/#5-why-do-i-still-have-to-sign-two-eip712-messages","title":"5. Why do I still have to sign two EIP712 messages?","text":"<p>Sending <code>approve()</code> transactions as a mean of assigning allowance for the transfer of ERC20 tokens requires users to hold native currencies to pay for gas. Requesting an approval for every single token transfers does not provide the smoothest user experience. A good workaround is to allocate a large amount of allowance for the spender, so users would only have to <code>approve()</code> once. This however places a huge amount of trust in the spender to not drain the user's allowance at will. To prevent exploitation, the spender is subjected to a secondary approval process which requires the user's signed EIP 712 message, without needing to pay for gas.</p> <p>The first signature is verified by the Conveyor relayer to collect ERC20 payment token, with the amount closely equivalent to the market gas price.</p> <p>The second message is sent to the NFTPlatform treasury contract to collect sales payment for the purchase of NFTs. Users may not be required to sign this message, if an NFT were to be distributed free of charge.</p>"},{"location":"witness/api/","title":"Witness API","text":"<p>JSON-RPC is a remote procedure call protocol encoded in JSON. You can use this API to send queries to our Geode instance for Witness.</p>"},{"location":"witness/api/#available-endpoints","title":"Available Endpoints","text":"Provider(s) URL(s) Witness Geode Mainnet https://witness-geode-mainnet.ata.network:3350"},{"location":"witness/api/#json-rpc-methods","title":"JSON-RPC Methods","text":""},{"location":"witness/api/#geode_witness_vote","title":"geode_witness_vote","text":"<p>Submits a signed Vote message in EIP712 format. </p>"},{"location":"witness/api/#endpoint","title":"Endpoint","text":"<p><code>https://witness-geode-mainnet.ata.network:3350/v0/geode_witness_vote</code></p>"},{"location":"witness/api/#return-code","title":"Return Code","text":"<p>Returns an integer representing the status of the operation.</p> Return Code Description 0 Success 1 SignatureFailure 2 ProposalNotActive 3 AlreadyVote 4 MissingWorkspace 5 IncorrectChainId 6 InternalError 7 WorkspaceDataError 8 ChainError 9 InsufficientBalance <p>The function takes in a signed vote in EIP712 format. </p>"},{"location":"witness/api/#data-format","title":"Data Format","text":""},{"location":"witness/api/#request-format","title":"Request Format","text":"<pre><code>{\n\"id\": 0,\n\"jsonrpc\": \"2.0\",\n\"method\": \"geode_witness_vote\",\n\"params\": {\n\"vote\": SignedEIP712Vote\n}\n}\n</code></pre>"},{"location":"witness/api/#signedeip712vote-format","title":"SignedEIP712Vote Format","text":"<p><pre><code>{\n\"msg\": EIP712Vote,\n\"v\": U256,\n\"r\": H256,\n\"s\": H256,\n}\n</code></pre> <pre><code>{\ntype: \"object\",\nproperties: {\nmsg: {type: \"object\"},\nv: {type: \"string\"},\nr: {type: \"string\"},\ns: {type: \"string\"}\n},\nrequired: [\"msg\", \"v\", \"r\", \"s\"]\n}\n</code></pre></p>"},{"location":"witness/api/#eip712vote-format","title":"EIP712Vote Format","text":"<p><pre><code>{\n\"types\": {\n\"EIP712Domain\": EIP712DomainType,\n\"Vote\": VoteType,\n},\n\"domain\": EIP712DomainData,\n\"primaryType\": String,\n\"message\": Vote,\n}\n</code></pre> <pre><code>{\ntype: \"object\",\nproperties: {\ntypes: {\ntype: \"object\",\nproperties: {\nEIP712Domain: {\ntype: \"array\",\nitems: {\nname: \"string\",\ntype: \"string\"\n},\nminItems: 4,\nmaxItems: 4\n},\nVote: {\ntype: \"array\",\nitems: {\nname: \"string\",\ntype: \"string\"\n},\nminItems: 4,\nmaxItems: 4\n},\n},\nrequired: [\"EIP712Domain\", \"Vote\"]\n},\ndomain: {\ntype: \"object\",\nproperties: {\nname: \"string\",\nversion: \"string\",\nchainId: \"string\",\nverifyingContract: \"string\"\n},\nrequired: [\"name\", \"version\", \"chainId\", \"verifyingContract\"]\n},\nprimaryType: {type: \"string\"},\nmessage: {type: \"object\"}\n},\nrequired: [\"types\", \"domain\", \"primaryType\", \"message\"]\n}\n</code></pre></p>"},{"location":"witness/api/#vote-format","title":"Vote Format","text":"<pre><code>{\ntype: \"object\",\nproperties: {\nvoter: \"string\",\nproposal: \"string\",\noption: \"number\",\ntimestamp: \"number\"\n},\nrequired: [\"voter\", \"primaryType\", \"domain\", \"message\"]\n}\n</code></pre>"},{"location":"witness/api/#sample-json-rpc-request","title":"Sample JSON-RPC Request","text":"<pre><code>{\n\"jsonrpc\":\"2.0\",\n\"method\":\"geode_witness_vote\",\n\"params\":{\n\"vote\":{\n\"msg\":{\n\"types\":{\n\"EIP712Domain\":[\n{\n\"name\":\"name\",\n\"type\":\"string\"\n},\n{\n\"name\":\"version\",\n\"type\":\"string\"\n},\n{\n\"name\":\"chainId\",\n\"type\":\"uint256\"\n},\n{\n\"name\":\"verifyingContract\",\n\"type\":\"address\"\n}\n],\n\"Vote\":[\n{\n\"name\":\"voter\",\n\"type\":\"uint256\"\n},\n{\n\"name\":\"proposal\",\n\"type\":\"uint256\"\n},\n{\n\"name\":\"option\",\n\"type\":\"uint32\"\n},\n{\n\"name\":\"timestamp\",\n\"type\":\"uint64\"\n}\n]\n},\n\"domain\":{\n\"name\":\"Witness\",\n\"version\":\"0.1.0\",\n\"chainId\":\"42\",\n\"verifyingContract\":\"0xdEB55768F6D1a3E6771A4096531aD6ea258A925e\"\n},\n\"primaryType\":\"Vote\",\n\"message\":{\n\"voter\":\"0x0000000000000000000000007ef99b0e5beb8ae42dbf126b40b87410a440a32a\",\n\"proposal\":\"0x10002c\",\n\"option\":2,\n\"timestamp\":1617188809\n}\n},\n\"v\":28,\n\"r\":\"0x491b2a733067508f789bb4d180329b1fd9327d79a8135997eada08b3217cbb72\",\n\"s\":\"0x4e48960bef350ea161c997c3c2e881329de0d09d4fddb5781c6719308cc6b260\"\n}\n},\n\"id\":73\n}\n</code></pre>"},{"location":"witness/api/#sample-response","title":"Sample Response","text":"<pre><code>{\n\"jsonrpc\":\"2.0\",\n\"result\":0,\n\"id\":73\n}\n</code></pre>"},{"location":"witness/api/#metamask-support","title":"Metamask Support","text":"<p>You can use Metamask for signing and sending the message by refering here: Sign-Typed-Data-v4.</p>"},{"location":"witness/introduction-bak/","title":"Introduction bak","text":""},{"location":"witness/introduction-bak/#overview","title":"Overview","text":"<p>The concept of community takes on tangible form and value as blockchain gains velocity. People with real financial stake change not only the proverbial status quo, but also foster new economies and polities in the image of Web3. With so many going about to decide the future of some of the biggest and most impactful decentralized projects, we thought about the experience we wanted communities to have, and how we could value-add to that journey. </p> <p>Witness was the result. A privacy-first, off-chance governance solution with on-chain execution. </p>"},{"location":"witness/introduction-bak/#features","title":"Features","text":"<ul> <li>Privacy   Users can select and change different privacy settings, which allows for specific results to be displayed. Public: Voter address, number of votes. Medium: Number of votes. Private: Only the overall result is shown. </li> <li>Gasless   Off-chain voting is gas-free. Users do not have to grapple with prohibitive gas fees to create proposals and vote on them.</li> <li>On-chain execution   Chainhook enables calling of the on-chain contract registered at proposal creation. </li> <li>Multi-chain support   Witness currently supports ERC20 on Ethereum, with other EVM-based chains and Substrate-based chains in the pipeline. </li> <li>Modular   Each function can be used standalone or together. It is entirely possible for a project to use Witness solely as a signaling tool. </li> </ul>"},{"location":"witness/introduction-bak/#platforms","title":"Platforms","text":"<p>Witness currently supports the following networks: </p> <ul> <li>Ethereum (Mainnet, Kovan Testnet)</li> <li>Binance Smart Chain (Mainnet, Testnet)</li> <li>Plasm Network (Dusty Testnet)</li> <li>Clover Finance (Testnet)</li> <li>Darwinia (Pangolin Testnet)</li> <li>Moonbase (Alpha Testnet)</li> <li>Polygon (Matic Mainnet)</li> <li>Avalanche (Mainnet)</li> <li>HECO (Mainnet, Testnet)</li> </ul>"},{"location":"witness/introduction-bak/#support","title":"Support","text":"Platform Private Voting Chainhook Public Voting Ethereum Mainnet Ethereum Kovan Testnet Binance Smart Chain Mainnet Binance Smart Chain Testnet Plasm Network Dusty Testnet Clover Finance Testnet Darwinia Pangolin Testnet Moonbase Alpha Testnet Polygon Avalanche HECO Mainnet HECO Testnet"},{"location":"witness/introduction/","title":"Introduction","text":""},{"location":"witness/introduction/#introduction","title":"Introduction","text":"<p>Note</p> <p>Please note: Currently, Witness has been upgraded to Anydao, please refer to here to know more about Anydao.</p>"},{"location":"witness/user-guide-bak/","title":"Getting started","text":""},{"location":"witness/user-guide-bak/#for-users","title":"For Users","text":"<ul> <li>Connect to the corresponding network </li> <li>Search for the project in the Search bar</li> <li>Cast your vote for an active proposal </li> </ul> <p>Attention</p> <p>Before voting, make sure that:</p> <ul> <li>Your MetaMask wallet is connected to the correct network. Read more about the blockchains we support here here and follow these instructions to add them to your wallet.</li> <li>Your account has the necessary number of ERC20/BEP20 tokens to qualify for the vote as specified by the block height in the snapshot.</li> </ul> <p> </p> <p>Note</p> <p>Find out how to obtain testnet tokens here.</p> <p>Results will be displayed after voting ends.</p> <p>Private proposals: Only the final outcome is shown. </p> <p></p> <p>Medium proposals: Number of votes for each option will be shown. </p> <p></p> <p>Public proposals: Voter information can be viewed by the public.</p> <p></p>"},{"location":"witness/user-guide-bak/#for-project-owners","title":"For Project Owners","text":"<p>There are a number of roles assigned with different levels of control. Project owners can create a workspace for hosting proposals. Project teams or community members are able to create proposals. Currently, the metadata is stored on the testnet of Automata Network. Connect to the testnet to create workspaces or propsals.</p>"},{"location":"witness/user-guide-bak/#adding-the-automata-network-testnet","title":"Adding the Automata Network testnet","text":"<p>Add the Automata Network to your existing network using the following details:  </p> Field Value Network Name Automata Network New RPC URL https://rpcv3.ata.network/ Chain ID 86 Currency Symbol ATA <p>Alternatively, add a new network by navigating to: </p> <ul> <li>Profile Picture &gt;&gt; Settings &gt;&gt; Networks &gt;&gt; Add Network </li> </ul> <p>or:</p> <ul> <li>Network name &gt;&gt; Custom RPC </li> </ul> <p></p>"},{"location":"witness/user-guide-bak/#connecting-your-metamask-wallet","title":"Connecting Your Metamask Wallet","text":"<p>If the Connect wallet button continues to show up, you are not connected.</p> <p> </p> <p>Follow these steps to connect your wallet:  </p> <ul> <li>Click on Connect wallet at the top right corner</li> <li>Click on MetaMask</li> <li>Select the account you wish to connect with MetaMask</li> <li>Connect your account</li> </ul> <p></p>"},{"location":"witness/user-guide-bak/#creating-a-workspace","title":"Creating a workspace","text":"<p>Create a workspace from the landing page.</p> <p>Tips</p> <p>Before creating a workspace for your token, ensure that:</p> <ul> <li>Your MetaMask wallet is connected to Automata Network</li> <li>Your account holds the necessary ATA tokens</li> </ul> <p>Jump ahead to Getting tokens for a detailed guide. </p> <p>Begin by:</p> <ul> <li>Clicking on Create</li> <li>Choose the correct blockchain network for your workspace</li> <li>Fill in your workspace name</li> <li>Fill in your workspace specifications</li> <li>Enter your token contract hash</li> <li>Click on Create</li> </ul> <p></p>"},{"location":"witness/user-guide-bak/#creating-a-new-proposal","title":"Creating a new proposal","text":"<p>Head over to the workspace to create a proposal. </p> <p></p> <p>Tips</p> <p>Before creating a proposal, ensure that:</p> <ul> <li>Your MetaMask wallet is connected to Automata Network</li> <li>Your account contains the necessary ATA tokens</li> </ul> <p>Jump ahead to Getting tokens for a detailed guide.</p> <p>Begin by:</p> <ul> <li>Clicking on New Proposal </li> <li>Fill in your proposal title</li> <li>Fill in content for your proposal</li> <li>Add / Edit / Remove your voting options</li> <li>Select the start and end date</li> <li>Click on Publish</li> </ul> <p></p>"},{"location":"witness/user-guide-bak/#chainhook","title":"Chainhook","text":"<p>This feature enables calling of the on-chain contract registered at proposal creation, across our list of supported networks.</p> <p>Each voting option can be followed with a chainhook. Or, create a chainhook by:</p> <ul> <li>Clicking on Add Chainhook followed by the option field</li> <li>Choose the smart contract language for your Chainhook</li> <li>Fill in the contract address where your Chainhook will take effect</li> <li>Fill in the function name</li> <li>Add arguments for your callback function</li> <li>Each argument is paired with the type and the value field</li> <li>Currently only <code>uint256, uint256[], address, address[]</code> are supported as argument types</li> <li>Follow the example for input value by hovering above the value field</li> </ul> <p></p>"},{"location":"witness/user-guide-bak/#appendix","title":"Appendix","text":""},{"location":"witness/user-guide-bak/#setting-up-metamask","title":"Setting up MetaMask","text":"<p>MetaMask is a cryptocurrency wallet used to interact with the Ethereum blockchain. Install the extension via the official download page here, or simply add the extension for your browser using the links below:</p> <ul> <li>Chrome</li> <li>Firefox</li> <li>Brave</li> <li>Edge</li> </ul>"},{"location":"witness/user-guide-bak/#getting-tokens","title":"Getting tokens","text":""},{"location":"witness/user-guide-bak/#getting-erc20-tokens-ethereum-kovan-network","title":"Getting ERC20 tokens (Ethereum Kovan Network)","text":"<ul> <li>Get tokens from Automata's faucet.</li> <li>Copy the address of your account in MetaMask by clicking on 'Copy to Clipboard' </li> <li>Paste the address into the input field for your desired token.</li> <li>Click Submit. </li> </ul> <p>When receiving ERC-20 tokens, the relevant contract hash can be found  next to the network name \"Ethereum Kovan Network\". This information can be copied by clicking on the Copy button.</p> <p></p>"},{"location":"witness/user-guide-bak/#getting-bep20-tokens-in-the-binance-smart-chain-test-network","title":"Getting BEP20 tokens in the Binance Smart Chain test network","text":"<ul> <li>To get tokens in the BSC test network, search for the contract address using https://testnet.bscscan.com/. </li> <li>Use the faucet https://testnet.venus.io/faucet or https://testnet.binance.org/faucet-smart to receive tokens.</li> </ul>"},{"location":"witness/user-guide-bak/#supported-chain-info","title":"Supported Chain Info","text":"Field Value Network Name BSC mainnet New RPC URL https://bsc-dataseed1.defibit.io/ Chain ID 56 Field Value Network Name BSC testnet New RPC URL https://data-seed-prebsc-1-s1.binance.org:8545/ Chain ID 97 Field Value Network Name Plasm Dusty testnet New RPC URL https://rpc.dusty.plasmnet.io:8545/ Chain ID 80 Field Value Network Name Clover testnet New RPC URL https://rpc.clover.finance/ Chain ID 1023 Field Value Network Name Dawinia Pangolin testnet New RPC URL https://pangolin-rpc.darwinia.network/ Chain ID 43 Field Value Network Name Moonbase Alpha testnet New RPC URL https://rpc.testnet.moonbeam.network/ Chain ID 1287 Field Value Network Name Polygon New RPC URL https://rpc-mainnet.matic.network Chain ID 137 Field Value Network Name Avalanche New RPC URL https://api.avax.network/ext/bc/C/rpc Chain ID 43114 <ul> <li>Ethereum Mainnet and Kovan Testnet are not listed here since they are supported by Metamask by deafult. </li> </ul>"},{"location":"witness/user-guide-bak/#get-supported-by-witness","title":"Get supported by Witness","text":"<p>We are happy to onboard more EVM networks onto Witness. Please provide the following details for us to get started with the integration: </p> <ul> <li>Chain ID</li> <li>JSON-RPC URL</li> <li>Blockchain Explorer URL (optional)</li> <li>Faucet (for testnet) </li> </ul>"},{"location":"witness/user-guide/","title":"User Guide","text":""},{"location":"witness/user-guide/#introduction","title":"Introduction","text":"<p>Note</p> <p>Please note: Currently, Witness has been upgraded to Anydao, please refer to here to know more about Anydao.</p>"},{"location":"xata/faq/","title":"FAQ","text":"<p>Frequently asked questions.</p> <ul> <li> <p>Will there be a XATA token?</p> <p>There are no plans to launch a XATA token at the moment. Please do not engage in any form of trade or liquidity farming with any XATA token out there in the wild.</p> </li> <li> <p>Are there any risks in providing liquidity to a liquidity pool such as ATA/USDT?</p> <p>Yes. All liquidity farming activities are subjected to the risk of impermanent loss. We suggest doing your own calculations as to whether yield farming and earning LP fees are more profitable than holding ATA to decide on the best course of action.</p> <p>More information on impermanent loss can be found in this article: https://academy.binance.com/en/articles/impermanent-loss-explained</p> </li> <li> <p>How do I connect on my mobile browser?</p> <p>Select Wallet Connect, which will generate a QR code. Use the mobile Metamask app to scan the QR code to approve transactions on your mobile browser.</p> </li> <li> <p>Why was my transaction rejected?</p> <p>There are many possible reasons. One of the most common is that users have insufficient tokens or propose too low a transaction fee. Periods of network congestion can also result in rejected transactions. If there's urgency to access a particular network, consider using other RPCs for each of these chains based on the articles below:</p> </li> </ul> <p>BSC RPCs: https://docs.binance.org/smart-chain/developer/rpc.html</p> <p>Polygon Aggregator RPC: https://blog.polygon.technology/polygon-rpc-gateway-will-provide-a-free-high-performance-connection-to-the-polygon-pos-blockchain/\u200b</p>"},{"location":"xata/farming-guide/","title":"Farming Guide","text":""},{"location":"xata/farming-guide/#step-by-step-guide-to-farming-on-xata","title":"Step-by-Step Guide to farming on XATA","text":""},{"location":"xata/farming-guide/#step-1-visit-the-farm-page","title":"Step 1 : Visit the Farm Page","text":"<p>You should be able to see the available farming pools by clicking on the 'Farm' tab in https://app.xata.fi/</p> <p></p> <p>Feel free to use the filter/search functions to find a pool for your favorite token, or the one you wish to stake.</p>"},{"location":"xata/farming-guide/#step-2-add-liquidity","title":"Step 2: Add Liquidity","text":"<p>If you have not already done this, head over to our Liquidity Pool Guide to add liquidity to the token pair.</p>"},{"location":"xata/farming-guide/#step-3-stake-lp-tokens","title":"Step 3: Stake LP tokens","text":"<p>After adding liquidity, return to the Farm page to stake. Click on the 'Stake Tokens' button after opening a farm</p> <p></p> <p>That's it, you're done! You should start seeing rewards in 'Rewards Earned' over time.</p>"},{"location":"xata/farming-guide/#claim-rewards","title":"Claim Rewards","text":"<p>At any point in time, you can claim your rewards without unstaking, by clicking ' Harvest' after opening a farm. This will send all accumulated reward tokens to your wallet.</p>"},{"location":"xata/farming-guide/#withdraw-or-exit-the-farm","title":"Withdraw or exit the farm","text":"<p>Unstake any amount of your LP tokens by clicking the 'Unstake Tokens' button. The remainder of your LP tokens will continue receiving rewards.</p> <p>If you wish to unstake all your LP tokens, you should click the 'Unstake All and Harvest' button instead. This will claim all rewards and unstake all of your LP tokens in the same transaction.</p>"},{"location":"xata/introduction/","title":"Introduction","text":"<p>XATA is a Fair Liquidity Provisioning protocol that minimizes Maximal Extractable Value (MEV), with anti-front-running supported across multiple chains including Polygon Network and Binance Smart Chain. </p> <p>Notably, Automata's approach does not rely on any miner bribe nor modification to address MEV. </p>"},{"location":"xata/introduction/#features","title":"Features","text":"<p>Powered by Conveyor, XATA creates an unalterable, front-running-free zone:</p> <ul> <li>Ordered privacy - Transaction ordering is not revealed unless it is determined and unalterable. No one, including hosting nodes, will know the ordering before it is decided.</li> <li>Gasless Transactions - Users pay gas fee directly in the tokens to be swapped. Native tokens (i.e. BNB, ETH) are no longer required when users are swapping tokens frequently. </li> <li>Chain Agnostic - XATA provides anti-front-running across multiple chains, including Polygon Network and Binance Smart Chain, with further support planned in the near future.</li> <li>No 3rd party involvment - As a stand-alone protocol, XATA does not require any additional miner bribe nor any prior modification on miners' part to work.</li> </ul>"},{"location":"xata/introduction/#how-xata-works","title":"How XATA works","text":"<p>XATA arranges transactions in a determined, unbiased order. On the protocol, users are able to view the amount of tokens saved from front-running directly as a result of MEV protection. </p> <ul> <li> <p>It is impossible for malicious actors to inject new transactions into XATA's output due to signature mismatch. </p> </li> <li> <p>It is also not possible to delete ordered transactions either, as transactions are broadcasted throughout the network.</p> </li> </ul>"},{"location":"xata/introduction/#get-started","title":"Get started","text":"<p>Check out this 2 minute video overview:</p> <p> Follow our in-depth guide to learn the basics of using XATA.</p>"},{"location":"xata/introduction/#resources","title":"Resources","text":"<ul> <li>Twitter</li> <li>MEV.tax</li> <li>Telegram</li> <li>Medium</li> </ul>"},{"location":"xata/liquiditypool-guide/","title":"Swap &amp; Liquidity Pool Guide","text":""},{"location":"xata/liquiditypool-guide/#connecting-your-wallet","title":"Connecting Your Wallet","text":"<p>Note</p> <p>Please note: Currently, XATA only supports the Polygon (MATIC) network &amp; Binance Smart Chain (BSC). Support for other chains will be launched very soon.</p> <p>For this guide, we will be using Metamask with a Polygon wallet address to connect to XATA. Please ensure that you have these ready:</p> <ul> <li> <p>Metamask extension installed to your chrome browser.</p> </li> <li> <p>Wallet address created on the Polygon Network - See this guide on how to set up a wallet and custom RPC for the Polygon Network.</p> </li> <li> <p>Ensure that you have some MATIC on your wallet address to pay for gas fees.</p> </li> </ul> <p>Once you have prepared everything, let's begin connecting our wallet to XATA:</p> <ul> <li>Head over to XATA at app.xata.fi.</li> <li>Click on \u201cConnect to a Wallet\u201d on the top right corner.</li> </ul> <p></p> <ul> <li>Select \u201cMetamask\u201d</li> </ul> <p></p> <ul> <li>The Metamask extension prompt will appear. Ensure that your account is checked with a tick and click \"Next\".</li> </ul> <p></p> <ul> <li>Another Metamask extension prompt will appear, click on \"Connect\".</li> </ul> <p></p> <p>If you have done everything right, the user\u2019s address and balance should appear on the top-right corner as shown in this image. </p>"},{"location":"xata/liquiditypool-guide/#swapping-tokens","title":"Swapping Tokens","text":"<ul> <li>Click on \"Swap\" at the top left corner.</li> <li>Select the tokens that you are swapping for.</li> </ul> <ul> <li>The token at the bottom is what you will receive for trading in the tokens at the top. The estimated output token amount will be calculated based on the tokens' monetary value ratio from the liquidity pool.</li> </ul> <ul> <li>Click on the gear icon to adjust the \"Slippage Tolerance\" and \"Transaction Deadline\" &amp; \"Multihop\" for your transaction if necessary.</li> </ul> <ul> <li>Slippage tolerance: The % of the price change that a user can tolerate. For instance, if the value were set at 0.5%, then the transaction will be reverted if the token price change is greater than 0.5%.</li> <li>Transaction deadline: The amount of time in seconds after the transaction is submitted. If a transaction were executed past the deadline, it will be reverted.</li> <li> <p>Multihop:  When a user is attempting to swap USDC for DAI, and such a LP pair does not exist, this trade must go through an intermediary token (USDT) from another existing LP pair. The trade route would look like this: USDC -&gt; USDT -&gt; DAI.</p> </li> <li> <p>Once you are ready, click on \"Swap\" and a prompt on XATA will appear. Click on \"Confirm Swap\" to proceed.</p> </li> </ul> <p></p> <ul> <li>Do take note that if you have not used these tokens on XATA before, you will need to approve each tokens when prompted before conducting the swap.</li> </ul> <p></p> <ul> <li>Next, a Metamask extension prompt will popup to request for signature. Click \"Sign\" to proceed.</li> </ul> <p></p> <ul> <li>Once this is done, your swap will be completed when the transaction is confirmed on the blockchain. You can also see how much MEV was protected in your trade using XATA.</li> </ul> <p></p>"},{"location":"xata/liquiditypool-guide/#liquidity-pools","title":"Liquidity Pools","text":"<p>You are also given the option to provide liquidity to XATA by creating a LP (Liquidity Pool) token pair.</p>"},{"location":"xata/liquiditypool-guide/#adding-liquidity","title":"Adding Liquidity","text":"<p>To do this, please follow these steps:</p> <ul> <li>Click on \"Pool\" in the top left hand corner.</li> </ul> <p></p> <ul> <li>Click on \"Add Liquidity\"</li> </ul> <p></p> <ul> <li>Click on the dropdown arrow to select each tokens for your LP pair, then key in the quantity for each.</li> </ul> <p></p> <p></p> <ul> <li>If you have not used these tokens on XATA before, you will need to click on approve tokens for each of them before you can \"Create Pool &amp; Supply\"</li> </ul> <p></p> <ul> <li>Once both tokens are approved, click \"Supply\", then click \"Create Pool &amp; Supply\" if you're creating a new liquidity pool.</li> </ul> <p></p> <ul> <li>A Metamask extension prompt for a Signature Request will popup. Click \"Sign\" to complete the process.</li> </ul> <p></p> <ul> <li>Once your transaction has been confirmed on the blockchain, you will receive your LP token as a representation of your equity of the pool.</li> </ul> <p></p>"},{"location":"xata/liquiditypool-guide/#removing-liquidity","title":"Removing Liquidity","text":"<ul> <li>To remove liquidity, click on \u201cPool\u201d to view all your liquidity pools. Then click on \"Manage\" on the liquidity pool of your choice. Then click \"Remove\".</li> </ul> <ul> <li>Next, select the percentage of liquidity you would like to remove from your pool. Then click \"Approve\".</li> </ul> <ul> <li>A Metamask extension prompt will appear for an approval, Click on \"Sign\" to proceed.</li> </ul> <ul> <li>Once approved, you can now click on the \"Remove\" button to trigger another signature request.</li> </ul> <ul> <li>A Metamask extension prompt for signature request will popup. Click on \"Sign\" again to proceed.</li> </ul> <ul> <li>The final confirmation popup on XATA will appear. Click on \"Confirm\" to complete the process.</li> </ul> <ul> <li>Once your transaction is confirmed on the blockchain, you will receive your tokens from the removed liquidity pool.</li> </ul>"},{"location":"xata/sdk/","title":"SDK","text":""},{"location":"xata/sdk/#the-xata-api-module","title":"The XATA-API module","text":"<p>The source code for this module can be found here on Github , inside the <code>./src/xata-api directory</code>.</p> <p>Each function within this module bundles the process of EIP712 signing, fee token calculation, and submitting meta transaction into a single workflow. The supported functions are the following:</p> <ul> <li><code>addLiquidity()</code></li> <li><code>swapExactTokensForTokens()</code></li> <li><code>swapTokensForExactTokens()</code></li> <li><code>removeLiquidity()</code></li> </ul> <p>Using this module, developers no longer required to manually construct a transaction request that looks like this: <pre><code>{\n\"method\": \"POST\",\n\"headers\": {\n\"Content-Type\": \"application/json\"\n},\n\"body\": \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"/v2/metaTx/swapTokensForExactTokens\\\",\\\"id\\\":1,\\\"params\\\":[\\\"137\\\",{\\\"types\\\":{\\\"EIP712Domain\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"version\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"chainId\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"verifyingContract\\\",\\\"type\\\":\\\"address\\\"}],\\\"Forwarder\\\":[{\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"feeToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"maxTokenAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"deadline\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"nonce\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"data\\\",\\\"type\\\":\\\"bytes\\\"},{\\\"name\\\":\\\"hashedPayload\\\",\\\"type\\\":\\\"bytes32\\\"}]},\\\"domain\\\":{\\\"name\\\":\\\"ConveyorV2\\\",\\\"version\\\":\\\"1\\\",\\\"chainId\\\":\\\"0x89\\\",\\\"verifyingContract\\\":\\\"0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB\\\"},\\\"primaryType\\\":\\\"Forwarder\\\",\\\"message\\\":{\\\"from\\\":\\\"0x10D73FE8e15414E7F1468eeb7A5A61A1aeec00C8\\\",\\\"feeToken\\\":\\\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\\\",\\\"maxTokenAmount\\\":\\\"0x01\\\",\\\"deadline\\\":\\\"0x6179545d\\\",\\\"nonce\\\":\\\"0x20\\\",\\\"data\\\":\\\"0xf208e6ab000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f185900000000000000000000000000000000000000000000000000000000000000a000000000000000000000000010d73fe8e15414e7f1468eeb7a5a61a1aeec00c8000000000000000000000000000000000000000000000000000000006179545d00000000000000000000000000000000000000000000000000000000000000020000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f\\\",\\\"hashedPayload\\\":\\\"0x5d299a1b988679b037e32d430bf2fbf03d5eb93949968c076c745ff2ffc18fe3\\\"}},\\\"28\\\",\\\"0xd8d7fdacaec4de579ee45c079cea896b576e994539f7980ec2ffb0c268fc07e3\\\",\\\"0x30dec79f68543f5785931f729ced63aabf5bc26219a11031150bced204d78ece\\\"]}\"\n}\n</code></pre> \u200b</p>"},{"location":"xata/sdk/#installation","title":"Installation","text":"<p>To use XATA-API module, you must first install the XATA SDK package from NPM.</p> <pre><code>yarn add @xatadev/sdk\n</code></pre> <p>We recommend you use Yarn to run the installation. If you prefer to use NPM (as some of us do!), just run the installation using this command:</p> <pre><code>npm i @xatadev/sdk\n</code></pre> <p>Warn</p> <p>It's best not to mix up the use of package managers to avoid resolution inconsistencies. Talk to your team and ask which package manager they are using.</p> <p>\u200b</p>"},{"location":"xata/sdk/#getting-started","title":"Getting Started","text":"<p>To use the module, simply do the following 3 steps:</p> <ol> <li> <p>Declare an instance of the XATA module. <pre><code>import { Xata } from '@xatadev/sdk';\n\u200b\nconst xataApi = new Xata();\n</code></pre></p> </li> <li> <p>Initiate the instance <pre><code>const feeToken = '&lt;0xAddress&gt;'\nawait xataApi.init(web3Provider, feeToken)\n\n// use this method to change the fee token\nconst otherFeeToken = '&lt;0xOtherAddress&gt;'\nawait xataApi.setFeeToken(otherFeeToken)\n</code></pre></p> </li> <li> <p>Interact with XATA</p> <p>You may now interact with the XATA router using Uniswap-like functions. These functions return API responses like the one below: <pre><code>// response example\n{\n\"jsonrpc\": \"2.0\",\n\"result\": {\n\"errorMessage\": null,\n\"success\": true,\n\"txnHash\": \"0x3a130c90692053f412a26f6d7914bb7637f0193c0a7054621d3e3c3a7d13c24a\"\n},\n\"id\": 1\n}\n</code></pre></p> </li> </ol> <p>We'll take a closer look at these functions in the following section. \u200b</p>"},{"location":"xata/sdk/#router-methods","title":"Router Methods","text":""},{"location":"xata/sdk/#add-liquidity","title":"Add Liquidity","text":"<p>Adds liquidity to the pool. If liquidity for the supplied pair does not exist in the pool then this router will initiate liquidity creation automatically.</p> <pre><code>await xataApi.addLiquidity(&lt;params&gt;)\n</code></pre> Parameter Type Description tokenA <code>string</code> Token A address tokenB <code>string</code> Token B address amountADesired <code>ethers.BigNumber</code> The amount of A added to the liquidity pool if the B/A price &lt;= (<code>amountBDesired</code>/<code>amountADesired</code>) amountBDesired <code>ethers.BigNumber</code> The amount of B added to the liquidity pool if the A/B price &lt;= (<code>amountADesired</code>/<code>amountBDesired</code>) amountAMin <code>ethers.BigNumber</code> Bounds the extent to which the B/A price can go up before the transaction reverts. Must be &lt;= <code>amountADesired</code> amountBMin <code>ethers.BigNumber</code> Bounds the extent to which the A/B price can go up before the transaction reverts. Must be &lt;= <code>amountBDesired</code> user <code>string</code> The user's address. The liquidity provider and the recipient of LP tokens deadline <code>BigNumber</code> Unix timestamp after which the transaction is reverted gasLimit <code>BigNumber</code> Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice <code>BigNumber</code> Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction"},{"location":"xata/sdk/#swap-exact-tokens-for-tokens","title":"Swap Exact Tokens For Tokens","text":"<p>Swap an exact amount of input tokens for as many output tokens as possible.</p> <pre><code>await xataApi.swapExactTokensForTokens(&lt;param&gt;)\n</code></pre> Parameter Type Description amountln <code>ethers.BigNumber</code> The amount of input tokens to send amountOutMin <code>ethers.BigNumber</code> The minimum amount of output tokens that must be received for the transaction not to revert. path <code>address[]</code> An array of token addresses. <code>path.length &gt;= 2</code> user <code>address</code> The user's address deadline <code>unit256</code> Unix timestamp after which the transaction is reverted gasLimit <code>BigNumber</code> Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice <code>BigNumber</code> Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction"},{"location":"xata/sdk/#swap-tokens-for-exact-tokens","title":"Swap Tokens For Exact Tokens","text":"<p>Receive an exact amount of output tokens for as few input tokens as possible.</p> <pre><code>await xataApi.swapTokensForExactTokens(&lt;params&gt;)\n</code></pre> Parameter Type Description amountOut <code>ethers.BigNumber</code> The amount of output tokens to receive amountInMax <code>ethers.BigNumber</code> The maximum amount of input tokens that must                                      be sent for the transaction not to revert. path <code>address[]</code> An array of token addresses. <code>path.length &gt;= 2</code> user <code>address</code> The user's address deadline <code>uint256</code> Unix timestamp after which the transaction is reverted gasLimit <code>BigNumber</code> Optional: Gas limit for calculating the token fee                                amount. This value may not be the actual gas limit used                          in the transaction gasPrice <code>BigNumber</code> Optional: Gas price for calculating the token fee                                amount. This value may not be the actual gas price used                          in the transaction"},{"location":"xata/sdk/#remove-liquidity","title":"Remove Liquidity","text":"<p>Withdraws a pair of tokens by burning LP tokens. This method consists of a 2-steps flow; it requires the LP holders to first sign a permit message, allowing the router to burn LP tokens, then proceeds with the actual LP tokens removal.</p> <p>First, sign the message by calling the permitLP function. (No gas required)</p> <pre><code>await xataApi.permitLP(&lt;params&gt;)\n</code></pre> Parameter Type Description pairAddr <code>string</code> The LP token address owner <code>string</code> The owner of the LP tokens. A.k.a. the user's address spender <code>string</code> The recipient address for the allowance. (XATA Router address) value <code>ethers.BigNumber</code> The liquidity value to approve nonce <code>ethers.BigNumber</code> The nonce used for signing the message deadline <code>uint256</code> Unix timestamp after which the transaction is reverted <p>It will return a Signature object that is required for removing liquidity.</p> <pre><code>{\n\"v\": number,\n\"r\": string,\n\"s\": string\n}\n</code></pre> <p>Once you receive the signature object from the permitLP then you can invoke the removeLiquidity function to withdraw tokens.</p> <pre><code>await xataApi.removeLiquidity(&lt;params&gt;)\n</code></pre> Parameter Type Description tokenA <code>string</code> Token A address tokenB <code>string</code> Token B address liquidity <code>ethers.BigNumber</code> The amount of liquidity to remove amountAMin <code>ethers.BigNumber</code> The amount of tokenA that must be received before the transaction reverts amountBMin <code>ethers.BigNumber</code> The amount of tokenB that must be received before the transaction reverts user <code>string</code> The user's address. The liquidity provider and the recipient of LP tokens deadline <code>BigNumber</code> Unix timestamp after which the transaction is reverted sig <code>SignatureLike</code> A signature object received from <code>permitLP()</code> gasLimit <code>BigNumber</code> Optional: Gas limit for calculating the token fee amount. This value may not be the actual gas limit used in the transaction gasPrice <code>BigNumber</code> Optional: Gas price for calculating the token fee amount. This value may not be the actual gas price used in the transaction"},{"location":"xata/sdk/#relay-config","title":"Relay Config","text":"<p>When a transaction request is successfully sent to one of the API routers, the transaction is forwarded and processed by Geode \u2013 one of our technologies that can increase privacy and eliminate trading MEV. To do this, the XATA SDK stores the Geode relay configuration as part of the API module.</p> <pre><code>...\n[ChainId.MATIC]: 'https://conveyor-prod-matic.ata.network',\n[ChainId.BSC]: 'https://conveyor-prod-bsc.ata.network',\n...\n</code></pre> <p>Developers can freely customize these endpoints to meet their application needs. To customize it, set new endpoint value(s) for each chain that is supported by your app. You can find the config here.</p>"},{"location":"xata/sdk/#using-a-test-relay-on-development","title":"Using a Test Relay on Development","text":"<p>XATA API works on production mode by default, and therefore the transaction request also gets forwarded to production-grade Geode. If you are under the development stage and want to test the transaction on a separate relay, you need to make a couple of changes.</p> <p>Update the relay configuration as in the previous section. What makes it different from the previous one is that you have to set the endpoint value(s) under the <code>Environment.STAGING</code> object instead of <code>Environment.PRODUCTION</code>.</p> <pre><code>[Environment.PRODUCTION]: {\n...\n[ChainId.MATIC]: 'https://conveyor-prod-matic.ata.network',\n[ChainId.BSC]: 'https://conveyor-prod-bsc.ata.network',\n...\n},\n[Environment.STAGING]: {\n...\n[ChainId.MATIC]: 'https://your-test-relay.endpoint',\n[ChainId.BSC]: 'https://your-test-relay.endpoint',\n...\n}\n</code></pre> <p>Update the XATA initiation code on your app.</p> <pre><code>// Add new Environment enum import\nimport { Environment, XATA } from '@xatadev/sdk'\n\u200b\nconst xataApi = new Xata();\nconst feeToken = '&lt;0xAddress&gt;'\n\n// Add 3rd param to override the SDK env mode\nawait xataApi.init(web3Provider, feeToken, Environment.STAGING);\n</code></pre>"},{"location":"xata/smart-contract/","title":"Smart Contracts","text":""},{"location":"xata/smart-contract/#what-do-these-contracts-do","title":"What do these contracts do?","text":"<p>Here are the official smart contract addresses for XATA on each network that we currently support. Please ensure that you are interacting with the correct contract addresses with your wallet to protect yourself from phishing attempts.</p> <ul> <li>Factory Contract - The \"Factory\" is responsible for creating new exchange contracts for each token pairs.</li> <li>Router Contract - The \"Router\" performs requirement checks needed for swapping tokens, adding liquidity, and removing liquidity.</li> </ul>"},{"location":"xata/smart-contract/#official-xata-smart-contract-addresses","title":"Official XATA Smart Contract Addresses","text":""},{"location":"xata/smart-contract/#polygon-network","title":"Polygon Network","text":"<p>Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7</p> <p>Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB</p> <p>Farm Contracts:</p> <ul> <li>ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a</li> </ul>"},{"location":"xata/smart-contract/#binance-smart-chain-network","title":"Binance Smart Chain Network","text":"<p>Factory Contract: 0x5f8017621825BC10D63d15C3e863f893946781F7</p> <p>Router Contract: 0xe4C5Cf259351d7877039CBaE0e7f92EB2Ab017EB</p> <p>Farm Contracts: </p> <ul> <li>ATA/USDT: 0x3dD417Ff4144bE35f203CB2CA569adF01Cd3574a</li> </ul>"}]}
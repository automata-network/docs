# TwoFactorBase

The base contract is responsible for passing the relayer's signature to be authenticated by the `TwoFactorAuthentication` contract. The contract then decides to execute or revert a transaction, depending on the data returned by the Authenticator.

## Constructor

```solidity
constructor (address _authenticator)
```

The address of the `TwoFactorAuthentication` contract is required to be passed onto the constructor, and then stored into the `twoFactorAuthenticator` variable, which is immutable.

## `enable2FAProtection`

```solidity
function enabled2FAProtection() external
```

Sets `enabled2FA = true`. This method enables 2FA protection for all methods with the `only2FA` modifier.

This method requires `onlyOwner`.

## `disable2FAProtection`

```solidity
function disabled2FAProtection() external
```

Sets `enabled2FA = false`. Methods with the `only2FA` modifier are no longer protected.

This method requires `onlyOwner`.

## `enabled2FA`

```solidity
function enabled2FA() public view returns(bool)
```

Queries the 2FA protection status of the contract.

## `only2FA`

```solidity
modifier only2FA(address primaryWallet)
```

Even though the modifier requires the input of a primary wallet address, this does not mean the sender necessarily needs to come from the same address as `primaryWallet`, as long as the embedded signature is generated by a trusted relayer.

Prior to sending a transaction to the contract, the relayer signs a message indicating that the primary wallet holder has provided a valid 2FA code. This signature must be appended into `msg.data`, which is later sliced out by the `only2FA` modifier to be sent to the Authenticator contract for verification.

See the [**Appendix**](2FAppendix.md) section to learn more about the signature extraction process.

---

Read more about [`TwoFactorAuthentication`](./TwoFactorAuthentication.md) to learn the signature verification process.